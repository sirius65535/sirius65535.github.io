<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Lv_ll的探究</title>
      <link href="/2018/05/14/lv_ll%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/05/14/lv_ll%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-ll-的作用"><a href="#1-lv-ll-的作用" class="headerlink" title="1 lv_ll 的作用"></a>1 lv_ll 的作用</h1><p>ll 为 linked list 的简写，即链表。LittlevGL 所创建的此模块主要是服务于需要使用链表功能的对象，如 group、obj、anim、chart 等。</p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>lv_ll 最形象的效果体现的 lv_group 上，在前面也探究过，群对象可以使用特定功能的两个按钮来实现“上一个”、“下一个”的切换，使用到了双链表中的“前驱、“后继”，具体效果体现这里不再赘述。</p><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_ll.h 中，先是定义了结点结构体的大小为1Byte，再是定义了链表的结构体，其中包含了头结点和尾结点。<br><img src="http://mypic666.test.upcdn.net/20180515200721.png" alt=""></p><p>下面是初始化双链表的函数，需要提供一个指针用于初始化，并设置结点的大小（单位为字节），同时还判断了设置的大小是否是4的倍数，不是的话匹配一个4为倍数大小的空间。<br><img src="http://mypic666.test.upcdn.net/20180515203414.png" alt=""></p><p>再就是为链表初始化一个头结点的函数，同时返回这个头结点的指针<br><img src="http://mypic666.test.upcdn.net/20180515203926.png" alt=""></p><p>下图这个函数的作用是在某个结点的前面插入一个新结点<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_set_next(ll_p, n_prev, n_new<span class="type"></span>);<span class="comment">//表示将上一个结点的后继设置为这个新结点</span></span><br><span class="line">node_set_prev(ll_p, n_new<span class="type"></span>, n_prev);<span class="comment">//表示将新结点的前驱设置为上一个结点</span></span><br><span class="line">node_set_prev(ll_p, n_act, n_new<span class="type"></span>);<span class="comment">//表示将下一个结点的前驱设置为新插入的结点</span></span><br><span class="line">node_set_next(ll_p, n_new<span class="type"></span>, n_act);<span class="comment">//表示将新结点的后继设置为下一个结点</span></span><br></pre></td></tr></table></figure></p><p>这样一来新结点就插入了双链表中了<br><img src="http://mypic666.test.upcdn.net/20180515204734.png" alt=""></p><p>而下面这个比较简单，就是在双链表的末尾添加新节点，在前面探讨群对象的时候也使用过<br><img src="http://mypic666.test.upcdn.net/20180515205936.png" alt=""></p><p>当然有了插入、添加结点，自然少不了删除结点，函数的开头则是将要删除的结点中的各种参数清空，再就是把要删除的结点的前后两个结点连接起来<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_ll_node_t* n_prev =  lv_ll_get_prev(<span class="keyword">ll_p, </span>node_p)<span class="comment">;//表示获取要删除的结点的前驱A</span></span><br><span class="line">lv_ll_node_t* n_next =  lv_ll_get_next(<span class="keyword">ll_p, </span>node_p)<span class="comment">;//表示获取要删除的结点的后继B</span></span><br><span class="line">node_set_next(<span class="keyword">ll_p, </span>n_prev, n_next)<span class="comment">;//表示将A的后继设置为B</span></span><br><span class="line">node_set_prev(<span class="keyword">ll_p, </span>n_next, n_prev)<span class="comment">;//表示将B的前驱设置为A</span></span><br></pre></td></tr></table></figure></p><p><img src="http://mypic666.test.upcdn.net/20180515210648.png" alt=""></p><p>下面这个函数的作用是释放掉这个双链表的所有结点，但是这个链表仍然存在，只是为空<br><img src="http://mypic666.test.upcdn.net/20180515211622.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，双向链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识11</title>
      <link href="/2018/05/13/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8611/"/>
      <url>/2018/05/13/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8611/</url>
      <content type="html"><![CDATA[<h1 id="1-错误和异常"><a href="#1-错误和异常" class="headerlink" title="1 错误和异常"></a>1 错误和异常</h1><p>Python有两种错误很容易辨认：语法错误和异常。</p><h2 id="1-1-语法错误"><a href="#1-1-语法错误" class="headerlink" title="1.1 语法错误"></a>1.1 语法错误</h2><p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">while</span> <span class="keyword">True</span> <span class="keyword">print</span>(<span class="string">'Hello world'</span>)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, in ?</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span> <span class="keyword">print</span>(<span class="string">'Hello world'</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。</p><p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p><a id="more"></a><h2 id="1-2-异常"><a href="#1-2-异常" class="headerlink" title="1.2 异常"></a>1.2 异常</h2><p>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p><p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ZeroDivisionError: division <span class="keyword">by</span> <span class="literal">zero</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">4</span> + spam*<span class="number">3</span></span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">NameError: name <span class="string">'spam'</span> is <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt; <span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">TypeError: Can<span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。</p><p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p><h2 id="1-3-异常处理"><a href="#1-3-异常处理" class="headerlink" title="1.3 异常处理"></a>1.3 异常处理</h2><p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = int(input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(<span class="string">"Oops!  That was no valid number.  Try again   "</span>)</span><br></pre></td></tr></table></figure><p>try语句按照如下方式工作；</p><ul><li>首先，执行try子句（在关键字try和关键字except之间的语句）</li><li>如果没有异常发生，忽略except子句，try子句执行后结束。</li><li>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。</li><li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。</li></ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'myfile.txt'</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"OS error: &#123;0&#125;"</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"Could not convert data to an integer."</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"Unexpected error:"</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">arg</span> <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    try:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="built_in">arg</span>, <span class="string">'r'</span>)</span><br><span class="line">    except IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'cannot open'</span>, <span class="built_in">arg</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">arg</span>, <span class="string">'has'</span>, <span class="built_in">len</span>(f.readlines()), <span class="string">'lines'</span>)</span><br><span class="line">        f.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。</p><p>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">this_fails</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        this_fails()</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> err:</span><br><span class="line">        print(<span class="string">'Handling run-time error:'</span>, err)</span><br><span class="line">   </span><br><span class="line">Handling run-time error: int division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure><h2 id="1-4-抛出异常"><a href="#1-4-抛出异常" class="headerlink" title="1.4 抛出异常"></a>1.4 抛出异常</h2><p>Python 使用 raise 语句抛出一个指定的异常。例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; raise NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line"><span class="symbol">NameError:</span> HiThere</span><br></pre></td></tr></table></figure><p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p><p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">        raise NameError('HiThere')</span><br><span class="line">    except NameError:</span><br><span class="line">        <span class="keyword">print</span>('<span class="keyword">An</span> exception flew <span class="keyword">by</span>!')</span><br><span class="line">        raise</span><br><span class="line">   </span><br><span class="line"><span class="keyword">An</span> exception flew <span class="keyword">by</span>!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="keyword">line</span> 2, <span class="keyword">in</span> ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><h2 id="1-5-用户自定义异常"><a href="#1-5-用户自定义异常" class="headerlink" title="1.5 用户自定义异常"></a>1.5 用户自定义异常</h2><p>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyError</span>(<span class="title">Exception</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, value)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.value = value</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> repr(<span class="keyword">self</span>.value)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="symbol">try:</span></span><br><span class="line">        raise MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line">    except MyError as <span class="symbol">e:</span></span><br><span class="line">        print(<span class="string">'My exception occurred, value:'</span>, e.value)</span><br><span class="line">   </span><br><span class="line">My exception occurred, <span class="symbol">value:</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; raise MyError(<span class="string">'oops!'</span>)</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">__main_<span class="number">_</span>.<span class="symbol">MyError:</span> <span class="string">'oops!'</span></span><br></pre></td></tr></table></figure><p>在这个例子中，类 Exception 默认的 <code>__init__()</code> 被覆盖。</p><p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, expression, message)</span>:</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Raised when an operation attempts a state transition that's not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。 </p><h2 id="1-6-定义清理行为"><a href="#1-6-定义清理行为" class="headerlink" title="1.6 定义清理行为"></a>1.6 定义清理行为</h2><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Goodbye, world!'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Goodbye, world!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure><p>以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。</p><p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。</p><p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def <span class="built_in">divide</span>(x, y):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">result</span> = x / y</span><br><span class="line">        except ZeroDivisionError:</span><br><span class="line">            print(<span class="string">"division by zero!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"result is"</span>, <span class="built_in">result</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            print(<span class="string">"executing finally clause"</span>)</span><br><span class="line">   </span><br><span class="line">&gt;&gt;&gt; <span class="built_in">divide</span>(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">result</span> is <span class="number">2.0</span></span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">divide</span>(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">division <span class="keyword">by</span> <span class="literal">zero</span>!</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">divide</span>(<span class="string">"2"</span>, <span class="string">"1"</span>)</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">Traceback (most recent call <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, <span class="built_in">line</span> <span class="number">3</span>, <span class="keyword">in</span> <span class="built_in">divide</span></span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> /: <span class="string">'str'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure><hr><h2 id="1-7-预定义的清理行为"><a href="#1-7-预定义的清理行为" class="headerlink" title="1.7 预定义的清理行为"></a>1.7 预定义的清理行为</h2><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p><p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">for</span> <span class="built_in">line</span> in <span class="built_in">open</span>(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">line</span>, <span class="built_in">end</span>=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p><p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"myfile.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">        print(<span class="built_in">line</span>, <span class="keyword">end</span>=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，错误和异常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识10</title>
      <link href="/2018/05/10/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8610/"/>
      <url>/2018/05/10/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8610/</url>
      <content type="html"><![CDATA[<h1 id="1-File-的使用"><a href="#1-File-的使用" class="headerlink" title="1 File 的使用"></a>1 File 的使用</h1><h2 id="1-1-读和写文件"><a href="#1-1-读和写文件" class="headerlink" title="1.1 读和写文件"></a>1.1 读和写文件</h2><p>open() 将会返回一个 file 对象，基本语法格式如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">(filename, mode)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>filename：filename 变量是一个包含了你要访问的文件名称的字符串值。</li><li>mode：mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li></ul><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>w</td><td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><a id="more"></a><table><thead><tr><th>模式</th><th>r</th><th>r+</th><th>w</th><th>w+</th><th>a</th><th>a+</th></tr></thead><tbody><tr><td>读</td><td>+</td><td>+</td><td></td><td>+</td><td></td><td>+</td></tr><tr><td>写</td><td></td><td>+</td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>创建</td><td></td><td></td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>覆盖</td><td></td><td></td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在开始</td><td>+</td><td>+</td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>指针在结尾</td><td></td><td></td><td></td><td></td><td>+</td><td>+</td></tr></tbody></table><p>例如创建一个新文件，并写入字符串进去，然后再读出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># coding=utf-8</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;\nwrite words for testing write \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">p_str=f2.read()</span><br><span class="line"></span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line">print(p_str)</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span> <span class="built_in">words</span> <span class="keyword">for</span> testing <span class="built_in">write</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h2 id="1-2-f-readline"><a href="#1-2-f-readline" class="headerlink" title="1.2 f.readline()"></a>1.2 f.readline()</h2><p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># coding=utf-8</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;write words for testing write \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">p_str=f2.readline()</span><br><span class="line">p_str2=f2.readline(10)</span><br><span class="line"></span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line">print(&quot;读取一行: &quot;+p_str)</span><br><span class="line">print(&quot;读取10个字符: &quot;+p_str2)</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取一行: <span class="built_in">write</span> <span class="built_in">words</span> <span class="keyword">for</span> testing <span class="built_in">write</span></span><br><span class="line"></span><br><span class="line">读取<span class="number">10</span>个字符: hello worl</span><br></pre></td></tr></table></figure></p><h2 id="1-3-f-redlines"><a href="#1-3-f-redlines" class="headerlink" title="1.3 f.redlines()"></a>1.3 f.redlines()</h2><p>f.readlines() 将返回该文件中包含的所有行。</p><p>如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># coding=utf-8</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;write words for testing write. \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">p_str=f2.readlines()</span><br><span class="line"></span><br><span class="line">f2.close()</span><br><span class="line"></span><br><span class="line">print(p_str)</span><br></pre></td></tr></table></figure></p><p>输出结果如下:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'write</span> words for testing write. \n', <span class="symbol">'hello</span> world\n']</span><br></pre></td></tr></table></figure></p><p>另一种方式是迭代一个文件对象然后读取每行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;write words for testing write. \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">for line in f2:</span><br><span class="line">print(line)</span><br><span class="line"></span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure></p><p>输出结果如下:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span> <span class="built_in">words</span> <span class="keyword">for</span> testing <span class="built_in">write</span>.</span><br><span class="line"></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h2 id="1-4-f-write"><a href="#1-4-f-write" class="headerlink" title="1.4 f.write()"></a>1.4 f.write()</h2><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">a=[&quot;abcd&quot;,123]</span><br><span class="line">b=str(a)</span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(b)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">p_str=f2.read()</span><br><span class="line"></span><br><span class="line">print(p_str)</span><br><span class="line"></span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure></p><p>输出结果如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">['abcd', <span class="number">123</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-5-f-tell"><a href="#1-5-f-tell" class="headerlink" title="1.5 f.tell()"></a>1.5 f.tell()</h2><p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">f1 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;write words for testing write. \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#关闭文件</span><br><span class="line">f1.close()</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">f2 =  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">p_str=f2.readline()</span><br><span class="line"></span><br><span class="line">#返回当前指针在文件中的位置</span><br><span class="line">pos=f2.tell()</span><br><span class="line"></span><br><span class="line">print(p_str)</span><br><span class="line"></span><br><span class="line">print(pos)</span><br><span class="line"></span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure></p><p>输出结果如下:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span> <span class="built_in">words</span> <span class="keyword">for</span> testing <span class="built_in">write</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure></p><h2 id="1-6-f-seek"><a href="#1-6-f-seek" class="headerlink" title="1.6 f.seek()"></a>1.6 f.seek()</h2><p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p><p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：</p><ul><li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li><li>seek(x,1) ： 表示从当前位置往后移动x个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li></ul><p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f = open(<span class="string">'a.txt'</span>, <span class="string">'wb+'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f.write(b<span class="string">'0123456789abcdef'</span>)</span></span><br><span class="line">16</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f.seek(5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f.read(1)</span></span><br><span class="line">b'5'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f.seek(-3, 2)</span></span><br><span class="line">13</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f.read(1)</span></span><br><span class="line">b'd'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="1-7-with…as…"><a href="#1-7-with…as…" class="headerlink" title="1.7 with…as…"></a>1.7 with…as…</h2><p>使用with…as…可以简化file的使用，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#在当前路径下创建一个a.txt文件并打开写入模式</span><br><span class="line">with  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;w&quot;)  as f1:</span><br><span class="line"></span><br><span class="line">#写入一段文字</span><br><span class="line">f1.write(&quot;write words for testing write. \nhello world\n&quot;)</span><br><span class="line"></span><br><span class="line">#打开刚才创建的文件并使用读取模式</span><br><span class="line">with  open(sys.path[0]+r&quot;\a.txt&quot;,&quot;r&quot;)  as f2:</span><br><span class="line"></span><br><span class="line">#读取字符串</span><br><span class="line">print(f2.read())</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span> <span class="built_in">words</span> <span class="keyword">for</span> testing <span class="built_in">write</span>.</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h2 id="1-8-pickle-模块"><a href="#1-8-pickle-模块" class="headerlink" title="1.8 pickle 模块"></a>1.8 pickle 模块</h2><p>python的pickle模块实现了基本的数据序列和反序列化。</p><p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p><p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>基本接口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pickle</span><span class="selector-class">.dump</span>(<span class="selector-tag">obj</span>, <span class="selector-tag">file</span>, <span class="selector-attr">[,protocol]</span>)</span><br></pre></td></tr></table></figure><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = pickle.load(file)</span><br></pre></td></tr></table></figure><p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p><p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p><p>实例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pickle模块将数据对象保存到文件</span></span><br><span class="line">data1 = &#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">         <span class="string">'b'</span>: (<span class="string">'string'</span>, <span class="string">u'Unicode string'</span>),</span><br><span class="line">         <span class="string">'c'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"></span><br><span class="line">selfref_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">selfref_list.append(selfref_list)</span><br><span class="line"></span><br><span class="line">output = open(<span class="string">'data.pkl'</span>, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></span><br><span class="line">pickle.dump(data1, output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle the list using the highest protocol available.</span></span><br><span class="line">pickle.dump(selfref_list, output, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">import pprint, pickle</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用pickle模块从文件中重构python对象</span></span><br><span class="line">pkl_file = <span class="built_in">open</span>(<span class="string">'data.pkl'</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">data1 = pickle.<span class="built_in">load</span>(pkl_file)</span><br><span class="line">pprint.pprint(data1)</span><br><span class="line"></span><br><span class="line">data2 = pickle.<span class="built_in">load</span>(pkl_file)</span><br><span class="line">pprint.pprint(data2)</span><br><span class="line"></span><br><span class="line">pkl_file.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，File </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识9</title>
      <link href="/2018/05/08/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%869/"/>
      <url>/2018/05/08/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%869/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-输入和输出"><a href="#1-Python3-输入和输出" class="headerlink" title="1 Python3 输入和输出"></a>1 Python3 输入和输出</h1><h2 id="1-1-输出格式美化"><a href="#1-1-输出格式美化" class="headerlink" title="1.1 输出格式美化"></a>1.1 输出格式美化</h2><p>Python两种输出值的方式: 表达式语句和 print() 函数。</p><p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。</p><p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p><p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p><ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'Hello, Google'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str(s)</span><br><span class="line"><span class="string">'Hello, Google'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; repr(s)</span><br><span class="line"><span class="string">"'Hello, Google'"</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str(<span class="number">1</span>/<span class="number">7</span>)</span><br><span class="line"><span class="string">'0.14285714285714285'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = <span class="number">10</span> * <span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; y = <span class="number">200</span> * <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = <span class="string">'x 的值为： '</span> + repr(x) + <span class="string">',  y 的值为：'</span> + repr(y) + <span class="string">'...'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(s)</span><br><span class="line">x 的值为： <span class="number">32.5</span>,  y 的值为：<span class="number">40000</span>...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment">#  repr() 函数可以转义字符串中的特殊字符</span></span><br><span class="line">... hello = <span class="string">'hello, Google\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; hellos = repr(hello)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(hellos)</span><br><span class="line"><span class="string">'hello, Google\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># repr() 的参数可以是 Python 的任何对象</span></span><br><span class="line">... repr((x, y, (<span class="string">'Google'</span>, <span class="string">'Baidu'</span>)))</span><br><span class="line"><span class="string">"(32.5, 40000, ('Google', 'Baidu'))"</span></span><br></pre></td></tr></table></figure><p>这里有两种方式输出一个平方与立方的表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">for x in  range(1, 11):</span><br><span class="line">print(repr(x).rjust(2),repr(x*x).rjust(3),repr(x*x*x).rjust(4))</span><br><span class="line"></span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line"></span><br><span class="line">for x in  range(1, 11):</span><br><span class="line">print(&apos;&#123;0:2d&#125;  &#123;1:3d&#125;  &#123;2:4d&#125;&apos;.format(x, x*x, x*x*x))</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格</p><p>str.format() 的基本使用如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">'&#123;&#125;网址： "&#123;&#125;!"'</span>.format(<span class="string">'淘宝'</span>, <span class="string">'www.taobao.com'</span>)) </span><br><span class="line">淘宝网址： <span class="string">"www.taobao.com!"</span></span><br></pre></td></tr></table></figure></p><p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。<br>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'&#123;0&#125; 和 &#123;1&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Baidu'</span>))</span></span><br><span class="line">Google 和 Baidu</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'&#123;1&#125; 和 &#123;0&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Baidu'</span>))</span></span><br><span class="line">Baidu 和 Google</span><br></pre></td></tr></table></figure></p><p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'&#123;name&#125;网址： &#123;site&#125;'</span>.format(name=<span class="string">'百度'</span>, site=<span class="string">'www.Baidu.com'</span>))</span></span><br><span class="line">百度网址： www.Baidu.com</span><br></pre></td></tr></table></figure><p>位置及关键字参数可以任意的结合:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。'</span>.format(<span class="string">'Google'</span>, <span class="string">'Baidu'</span>,other=<span class="string">'Taobao'</span>))</span></span><br><span class="line">站点列表 Google, Baidu, 和 Taobao。</span><br></pre></td></tr></table></figure><p>‘!a’ (使用 ascii()), ‘!s’ (使用 str()) 和 ‘!r’ (使用 repr()) 可以用于在格式化某个值之前对其进行转化:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import <span class="built_in">math</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">'常量 PI 的值近似为： &#123;&#125;。'</span>.<span class="built_in">format</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">'常量 PI 的值近似为： &#123;!r&#125;。'</span>.<span class="built_in">format</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br></pre></td></tr></table></figure><p>可选项 ‘:’ 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import <span class="built_in">math</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">'常量 PI 的值近似为 &#123;0:.3f&#125;。'</span>.<span class="built_in">format</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>))</span><br><span class="line">常量 PI 的值近似为 <span class="number">3.142</span>。</span><br></pre></td></tr></table></figure><p>在 ‘:’ 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">table</span> = &#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Baidu'</span>: <span class="number">2</span>, <span class="string">'Taobao'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> name, number <span class="keyword">in</span> <span class="built_in">table</span>.items():</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">'&#123;0:10&#125; ==&gt; &#123;1:10d&#125;'</span>.format(name, number))</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">Baidu</span>      ==&gt;</span>          <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">Taobao</span>     ==&gt;</span>          <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">Google</span>     ==&gt;</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。</p><p>最简单的就是传入一个字典, 然后使用方括号 ‘[]’ 来访问键值 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; table = &#123;<span class="string">'Google'</span>: 1, <span class="string">'Baidu'</span>: 2, <span class="string">'Taobao'</span>: 3&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'Baidu: &#123;0[Baidu]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;'</span>.format(table))</span></span><br><span class="line">Baidu: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure><p>也可以通过在 table 变量前使用 ‘**’ 来实现相同的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; table = &#123;<span class="string">'Google'</span>: 1, <span class="string">'Baidu'</span>: 2, <span class="string">'Taobao'</span>: 3&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'Baidu: &#123;Baidu:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;'</span>.format(**table))</span></span><br><span class="line">Baidu: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure><h2 id="1-2-旧式字符串格式化"><a href="#1-2-旧式字符串格式化" class="headerlink" title="1.2 旧式字符串格式化"></a>1.2 旧式字符串格式化</h2><p>% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import math</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'常量 PI 的值近似为：%5.3f。'</span> % math.pi)</span></span><br><span class="line">常量 PI 的值近似为：3.142。</span><br></pre></td></tr></table></figure><p>因为 str.format() 比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p><h2 id="1-3-读取键盘输入"><a href="#1-3-读取键盘输入" class="headerlink" title="1.3 读取键盘输入"></a>1.3 读取键盘输入</h2><p>Python提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。<br>input 可以接收一个Python表达式作为输入，并将运算结果返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">str  =  input(&quot;请输入：&quot;);</span><br><span class="line">print (&quot;你输入的内容是: &quot;, str)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入：fucku</span><br><span class="line"><span class="section">你输入的内容是:  fucku</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，输入和输出 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识8</title>
      <link href="/2018/05/04/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%868/"/>
      <url>/2018/05/04/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%868/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-模块"><a href="#1-Python3-模块" class="headerlink" title="1 Python3 模块"></a>1 Python3 模块</h1><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。<br>下面是一个使用 python 标准库中模块的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># 此文件名: test_module.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print(&apos;命令行参数如下:&apos;)</span><br><span class="line">for i in sys.argv:</span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line">print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;)</span><br></pre></td></tr></table></figure></p><p>带参执行如下：</p><a id="more"></a><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\A</span>cer&gt; py -3 "e:/Python3 Study/test_module.py" test1 test2 test3</span><br><span class="line">命令行参数如下:</span><br><span class="line">e:/Python3 Study/test_module.py</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： ['e:<span class="symbol">\\</span>Python3 Study', 'C:<span class="symbol">\\</span>Python36<span class="symbol">\\</span>python36.zip', 'C:<span class="symbol">\\</span>Python36<span class="symbol">\\</span>DLLs', 'C:<span class="symbol">\\</span>Python36<span class="symbol">\\</span>lib', 'C:<span class="symbol">\\</span>Python36', 'C:<span class="symbol">\\</span>Python36<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages']</span><br></pre></td></tr></table></figure><ul><li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li><li>2、sys.argv 是一个包含命令行参数的列表。</li><li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li></ul><h2 id="1-1-import-语句"><a href="#1-1-import-语句" class="headerlink" title="1.1 import 语句"></a>1.1 import 语句</h2><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">module</span><span class="number">1</span>[, <span class="keyword">module</span><span class="number">2</span>[,... moduleN]</span><br></pre></td></tr></table></figure></p><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。<br>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 test_module，需要把命令放在脚本的顶端：</p><p>test_module.py 文件代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># Filename: test_module.py</span><br><span class="line"></span><br><span class="line">def  print_func( par ):</span><br><span class="line">print (&quot;Hello : &quot;, par)</span><br><span class="line">return</span><br></pre></td></tr></table></figure></p><p>test2.py 引入 support 模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># Filename: test2.py</span><br><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import test_module</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 现在可以调用模块里包含的函数了</span><br><span class="line">test_module.print_func(sys.argv[1])</span><br></pre></td></tr></table></figure></p><p>以上实例输出结果：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\Users\Acer&gt; py <span class="number">-3</span> <span class="string">"e:/Python3 Study/test2.py"</span> Google_123</span><br><span class="line"><span class="string">Hello :</span>  Google_123</span><br></pre></td></tr></table></figure></p><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p><p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p><p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p><p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import sys</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'C:\\Python36\\python36.zip'</span>, <span class="string">'C:\\Python36\\DLLs'</span>, <span class="string">'C:\\Python36\\lib'</span>, <span class="string">'C:\\Python36'</span>, <span class="string">'C:\\Python36\\lib\\site-packages'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p><p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p><p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p><p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个test2.py的文件，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># Filename: test2.py</span><br><span class="line"></span><br><span class="line"># 斐波那契(fibonacci)数列模块</span><br><span class="line"></span><br><span class="line">def  fib(n): # 定义到 n 的斐波那契数列</span><br><span class="line">a, b =  0, 1</span><br><span class="line">while b &lt; n:</span><br><span class="line">print(b, end=&apos;  &apos;)</span><br><span class="line">a, b = b, a+b</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">def  fib2(n): # 返回到 n 的斐波那契数列</span><br><span class="line">result =  []</span><br><span class="line">a, b =  0, 1</span><br><span class="line">while b &lt; n:</span><br><span class="line">result.append(b)</span><br><span class="line">a, b = b, a+b</span><br><span class="line">return result</span><br></pre></td></tr></table></figure></p><p>然后进入Python3解释器，使用下面的命令导入这个模块：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> test2</span><br></pre></td></tr></table></figure></p><p>这样做并没有把直接定义在test2中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p><p>可以使用模块名称来访问函数：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; test2.fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br><span class="line">&gt;&gt;&gt; test2.fib(<span class="number">900</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span></span><br></pre></td></tr></table></figure><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = test2.fib</span><br><span class="line">&gt;&gt;&gt; a(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-from…import-语句"><a href="#1-2-from…import-语句" class="headerlink" title="1.2 from…import 语句"></a>1.2 from…import 语句</h2><p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure></p><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from test2 import fib,fib2</span><br><span class="line">&gt;&gt;&gt; fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p><h2 id="1-3-name-属性"><a href="#1-3-name-属性" class="headerlink" title="1.3 __name__属性"></a>1.3 __name__属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># Filename: test.py</span><br><span class="line"></span><br><span class="line">if __name__ ==  &apos;__main__&apos;:</span><br><span class="line">print(&apos;程序自身在运行&apos;)</span><br><span class="line">else:</span><br><span class="line">print(&apos;我来自另一模块&apos;)</span><br></pre></td></tr></table></figure></p><p>执行如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\Users\Acer&gt; py <span class="number">-3</span> <span class="string">"e:/Python3 Study/test.py"</span></span><br><span class="line">程序自身在运行</span><br></pre></td></tr></table></figure></p><p>在解释器中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import <span class="built_in">test</span></span></span><br><span class="line">我来自另一模块 </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="1-4-dir-函数"><a href="#1-4-dir-函数" class="headerlink" title="1.4 dir() 函数"></a>1.4 dir() 函数</h2><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import test2,sys</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir(test2)</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir(sys)</span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__interactivehook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>, <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_enablelegacywindowsfsencoding'</span>, <span class="string">'_getframe'</span>, <span class="string">'_git'</span>, <span class="string">'_home'</span>, <span class="string">'_xoptions'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>, <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>, <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>, <span class="string">'dllhandle'</span>, <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>, <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>, <span class="string">'get_asyncgen_hooks'</span>, <span class="string">'get_coroutine_wrapper'</span>, <span class="string">'getallocatedblocks'</span>, <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getfilesystemencodeerrors'</span>, <span class="string">'getfilesystemencoding'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>, <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettrace'</span>, <span class="string">'getwindowsversion'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>, <span class="string">'intern'</span>, <span class="string">'is_finalizing'</span>, <span class="string">'last_traceback'</span>, <span class="string">'last_type'</span>, <span class="string">'last_value'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>, <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>, <span class="string">'ps2'</span>, <span class="string">'set_asyncgen_hooks'</span>, <span class="string">'set_coroutine_wrapper'</span>, <span class="string">'setcheckinterval'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>, <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>, <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>, <span class="string">'winver'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import test2</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; abc = test2.fib</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir()</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'abc'</span>, <span class="string">'test2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir()</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'a'</span>, <span class="string">'abc'</span>, <span class="string">'test2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; del a</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir()</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'abc'</span>, <span class="string">'test2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="1-5-标准模块"><a href="#1-5-标准模块" class="headerlink" title="1.5 标准模块"></a>1.5 标准模块</h2><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。 有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。 这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。 应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import sys</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sys.ps1</span></span><br><span class="line">'&gt;&gt;&gt; '</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sys.ps2</span></span><br><span class="line">'... '</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sys.ps1 = <span class="string">'E&gt;'</span></span></span><br><span class="line"><span class="meta">E&gt;</span><span class="bash"><span class="built_in">print</span>(<span class="string">'new!'</span>)</span></span><br><span class="line">new!</span><br><span class="line"><span class="meta">E&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><h2 id="1-6-包"><a href="#1-6-包" class="headerlink" title="1.6 包"></a>1.6 包</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p><p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p><p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p><p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p><p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p><p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，: file:.aiff，: file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p><p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p><p>这里给出了一种可能的包结构（在分层的文件系统中）:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sound/                          顶层包</span><br><span class="line">__init__<span class="selector-class">.py</span>               初始化 sound 包       </span><br><span class="line">formats/                  文件格式转换子包               </span><br><span class="line">__init__<span class="selector-class">.py</span>               </span><br><span class="line">wavread<span class="selector-class">.py</span>               </span><br><span class="line">wavwrite<span class="selector-class">.py</span>               </span><br><span class="line">aiffread<span class="selector-class">.py</span>               </span><br><span class="line">aiffwrite<span class="selector-class">.py</span>               </span><br><span class="line">auread<span class="selector-class">.py</span>               </span><br><span class="line">auwrite<span class="selector-class">.py</span>               </span><br><span class="line">...      </span><br><span class="line">effects/                  声音效果子包               </span><br><span class="line">__init__<span class="selector-class">.py</span>               </span><br><span class="line">echo<span class="selector-class">.py</span>               </span><br><span class="line">surround<span class="selector-class">.py</span>              </span><br><span class="line">reverse<span class="selector-class">.py</span>               </span><br><span class="line">...       </span><br><span class="line">filters/                  </span><br><span class="line">filters 子包              </span><br><span class="line">__init__<span class="selector-class">.py</span>              </span><br><span class="line">equalizer<span class="selector-class">.py</span>               </span><br><span class="line">vocoder<span class="selector-class">.py</span>               </span><br><span class="line">karaoke<span class="selector-class">.py</span>               </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p><p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p><p>最简单的情况，放一个空的 : file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） <strong>all</strong>变量赋值。</p><p>用户可以每次只导入一个包里面的特定模块，比如:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sound<span class="selector-class">.effects</span><span class="selector-class">.echo</span></span><br></pre></td></tr></table></figure></p><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sound<span class="selector-class">.effects</span><span class="selector-class">.echo</span><span class="selector-class">.echofilter</span>(<span class="selector-tag">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>还有一种导入子模块的方法是:</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure><p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo.echofilter(input, output, <span class="attribute">delay</span>=0.7, <span class="attribute">atten</span>=4)</span><br></pre></td></tr></table></figure><p>还有一种变化就是直接导入一个函数或者变量:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sound<span class="selector-class">.effects</span><span class="selector-class">.echo</span> import echofilter</span><br></pre></td></tr></table></figure><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p><p>echofilter(input, output, delay=0.7, atten=4)</p><p>注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p><p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个: exc:ImportError 异常被抛出了。</p><p>反之，如果使用形如import item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p><h2 id="1-7-从一个包中导入"><a href="#1-7-从一个包中导入" class="headerlink" title="1.7 从一个包中导入*"></a>1.7 从一个包中导入*</h2><p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p><p>Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p><p>但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p><p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。</p><p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p><p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p><p>导入语句遵循如下规则：如果包定义文件 <strong>init</strong>.py 存在一个叫做 <strong>all</strong> 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。</p><p>作为包的作者，可别忘了在更新包之后保证 <strong>all</strong> 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在: file:sounds/effects/<strong>init</strong>.py中包含如下代码:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">__all__</span> = [<span class="string">"echo"</span>, <span class="string">"surround"</span>, <span class="string">"reverse"</span>]</span><br></pre></td></tr></table></figure><p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p><p>如果 <strong><strong>all</strong></strong> 真的没有定义，那么使用<strong>from sound.effects import *</strong>这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行<strong>init</strong>.py里定义的初始化代码）。</p><p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sound<span class="selector-class">.effects</span><span class="selector-class">.echo</span></span><br><span class="line">import sound<span class="selector-class">.effects</span><span class="selector-class">.surround</span></span><br><span class="line">from sound<span class="selector-class">.effects</span> import *</span><br></pre></td></tr></table></figure><p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了<strong>all</strong>就更没问题了）</p><p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p><p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p><p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包sound.effects中的模块echo，你就要写成 from sound.effects import echo。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p><p>包还提供一个额外的属性<strong>path</strong>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，你得在其他<strong>init</strong>.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p><p>这个功能并不常用，一般用来扩展包里面的模块。</p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，模块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识7</title>
      <link href="/2018/05/02/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%867/"/>
      <url>/2018/05/02/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%867/</url>
      <content type="html"><![CDATA[<h1 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h1><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><a id="more"></a><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><p>Python 定义函数使用 def 关键字，一般格式如下：<br><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">函数名（参数列表）</span></span>:     </span><br><span class="line">函数体</span><br></pre></td></tr></table></figure></p><p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line"># 计算三角形面积函数</span><br><span class="line">def  area(width, height):</span><br><span class="line">return width * height/2</span><br><span class="line"></span><br><span class="line">def  print_welcome(name):</span><br><span class="line">print(&quot;Welcome&quot;, name)</span><br><span class="line"></span><br><span class="line">print_welcome(&quot;Double666&quot;)</span><br><span class="line">w =  8</span><br><span class="line">h =  9</span><br><span class="line">print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; triangle_area =&quot;,area(w, h))</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome Double666</span><br><span class="line">width = <span class="number">8</span>  height = <span class="number">9</span>  triangle_area = <span class="number">36.0</span></span><br></pre></td></tr></table></figure></p><h2 id="1-2-函数调用"><a href="#1-2-函数调用" class="headerlink" title="1.2 函数调用"></a>1.2 函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line"># 定义函数</span><br><span class="line">def  printme( str ):</span><br><span class="line">print (str)</span><br><span class="line">return</span><br><span class="line"># 调用函数</span><br><span class="line">printme(&quot;调用自定义函数&quot;)</span><br><span class="line">printme(&quot;再次调用同一函数&quot;)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用自定义函数</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure></p><h2 id="1-3-传递参数"><a href="#1-3-传递参数" class="headerlink" title="1.3 传递参数"></a>1.3 传递参数</h2><p>在 python 中，类型属于对象，变量是没有类型的：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="attr">b</span>=<span class="string">"Google"</span></span><br></pre></td></tr></table></figure></p><p>以上代码中，<strong>[1,2,3]</strong> 是 List 类型，<strong>“Google”</strong> 是 String 类型，而变量 a 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象</p><h2 id="1-4-可更改-mutable-与不可更改-immutable-对象"><a href="#1-4-可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="1.4 可更改(mutable)与不可更改(immutable)对象"></a>1.4 可更改(mutable)与不可更改(immutable)对象</h2><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><p><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</p></li><li><p><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p></li></ul><p>python 函数的参数传递：</p><ul><li><p><strong>不可变类型：</strong>类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），<strong>传递的只是a的值，没有影响a对象本身</strong>。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</p></li><li><p><strong>可变类型：</strong>类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</p></li></ul><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h2 id="1-5-python-传不可变对象实例"><a href="#1-5-python-传不可变对象实例" class="headerlink" title="1.5 python 传不可变对象实例"></a>1.5 python 传不可变对象实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  ChangeInt( a ):</span><br><span class="line">a =  10</span><br><span class="line"></span><br><span class="line">b =  2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b )</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p><h2 id="1-6-传可变对象实例"><a href="#1-6-传可变对象实例" class="headerlink" title="1.6 传可变对象实例"></a>1.6 传可变对象实例</h2><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  changeme( mylist ):</span><br><span class="line">&quot;修改传入的列表&quot;</span><br><span class="line">mylist.append([1,2,3,4])</span><br><span class="line">print (&quot;函数内取值: &quot;, mylist)</span><br><span class="line">return</span><br><span class="line"># 调用changeme函数</span><br><span class="line">mylist =  [10,20,30]</span><br><span class="line">changeme( mylist )</span><br><span class="line">print (&quot;函数外取值: &quot;, mylist)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内取值:  <span class="comment">[10, 20, 30, <span class="comment">[1, 2, 3, 4]</span>]</span></span><br><span class="line">函数外取值:  <span class="comment">[10, 20, 30, <span class="comment">[1, 2, 3, 4]</span>]</span></span><br></pre></td></tr></table></figure></p><h2 id="1-7-参数"><a href="#1-7-参数" class="headerlink" title="1.7 参数"></a>1.7 参数</h2><p>以下是调用函数时可使用的正式参数类型：</p><ul><li>必需参数</li><li>关键字参数</li><li>默认参数</li><li>不定长参数</li></ul><h3 id="1-7-1-必须参数"><a href="#1-7-1-必须参数" class="headerlink" title="1.7.1 必须参数"></a>1.7.1 必须参数</h3><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  printme( str ):</span><br><span class="line">&quot;打印任何传入的字符串&quot;</span><br><span class="line">print (str)</span><br><span class="line">return</span><br><span class="line">#调用printme函数</span><br><span class="line">printme()</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">468</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() <span class="keyword">missing</span> <span class="number">1</span> <span class="keyword">required</span> positional argument: <span class="string">'str'</span></span><br></pre></td></tr></table></figure></p><h3 id="1-7-2-关键字参数"><a href="#1-7-2-关键字参数" class="headerlink" title="1.7.2 关键字参数"></a>1.7.2 关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>以下实例在函数 printme() 调用时使用参数名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">#可写函数说明</span><br><span class="line">def  printme( str ):</span><br><span class="line">&quot;打印任何传入的字符串&quot;</span><br><span class="line">print (str)</span><br><span class="line">return</span><br><span class="line">#调用printme函数</span><br><span class="line">printme( str = &quot;Google&quot;)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Google</span></span><br></pre></td></tr></table></figure></p><p>以下实例中演示了函数参数的使用不需要使用指定顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">#可写函数说明</span><br><span class="line">def  printinfo( name, age ):</span><br><span class="line">&quot;打印任何传入的字符串&quot;</span><br><span class="line">print (&quot;名字: &quot;, name)</span><br><span class="line">print (&quot;年龄: &quot;, age)</span><br><span class="line">return</span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=21, name=&quot;Jane&quot; )</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">名字:  Jane</span></span><br><span class="line"><span class="section">年龄:  21</span></span><br></pre></td></tr></table></figure></p><h3 id="1-7-3-默认参数"><a href="#1-7-3-默认参数" class="headerlink" title="1.7.3 默认参数"></a>1.7.3 默认参数</h3><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  printinfo( name, age  =  35 ):</span><br><span class="line">&quot;打印任何传入的字符串&quot;</span><br><span class="line">print (&quot;名字: &quot;, name)</span><br><span class="line">print (&quot;年龄: &quot;, age)</span><br><span class="line">return</span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;Jack&quot; )</span><br><span class="line">print (&quot;------------------------&quot;)</span><br><span class="line">printinfo( name=&quot;Mike&quot; )</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名字:  Jack</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  Mike</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure></p><h3 id="1-7-3-不定长参数"><a href="#1-7-3-不定长参数" class="headerlink" title="1.7.3 不定长参数"></a>1.7.3 不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line"># 可写函数说明</span><br><span class="line">def  printinfo( arg1, *vartuple ):</span><br><span class="line">&quot;打印任何传入的参数&quot;</span><br><span class="line">print (&quot;输出: &quot;)</span><br><span class="line">print (arg1)</span><br><span class="line">for var in vartuple:</span><br><span class="line">print (var)</span><br><span class="line">return</span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 10 )</span><br><span class="line">printinfo( 70, 60, 50 )</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输出:</span></span><br><span class="line">10</span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure></p><h3 id="1-7-3-匿名函数"><a href="#1-7-3-匿名函数" class="headerlink" title="1.7.3 匿名函数"></a>1.7.3 匿名函数</h3><p>python 使用 lambda 来创建匿名函数。</p><p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p><ul><li>lambda 只是一个表达式，函数体比 def 简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率</li></ul><p>lambda 函数的语法只包含一个语句，如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure></p><p>如下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line"># 可写函数说明</span><br><span class="line">sum  =  lambda  arg1, arg2: arg1 + arg2</span><br><span class="line"># 调用sum函数</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure></p><h2 id="1-8-return语句"><a href="#1-8-return语句" class="headerlink" title="1.8 return语句"></a>1.8 return语句</h2><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line"># 可写函数说明</span><br><span class="line">def  sum( arg1, arg2 ):</span><br><span class="line"># 返回2个参数的和.&quot;</span><br><span class="line">total = arg1 + arg2</span><br><span class="line">print (&quot;函数内 : &quot;, total)</span><br><span class="line">return total</span><br><span class="line"></span><br><span class="line"># 调用sum函数</span><br><span class="line">a =  sum( 10, 20 )</span><br><span class="line">print (&quot;函数外 : &quot;, a)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure></p><h2 id="1-9-全局变量和局部变量"><a href="#1-9-全局变量和局部变量" class="headerlink" title="1.9 全局变量和局部变量"></a>1.9 全局变量和局部变量</h2><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。<br>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">total =  0  # 这是一个全局变量</span><br><span class="line"># 可写函数说明</span><br><span class="line">def  sum( arg1, arg2 ):</span><br><span class="line">#返回2个参数的和.&quot;</span><br><span class="line">total = arg1 + arg2 # total在这里是局部变量.</span><br><span class="line">print (&quot;函数内是局部变量 : &quot;, total)</span><br><span class="line">return total</span><br><span class="line"></span><br><span class="line">#调用sum函数</span><br><span class="line">sum( 10, 20 )</span><br><span class="line">print (&quot;函数外是全局变量 : &quot;, total)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure></p><h2 id="1-10-global-和-nonlocal关键字"><a href="#1-10-global-和-nonlocal关键字" class="headerlink" title="1.10 global 和 nonlocal关键字"></a>1.10 global 和 nonlocal关键字</h2><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。<br>以下实例修改全局变量 num：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">num =  1</span><br><span class="line">def  fun1():</span><br><span class="line">global num # 需要使用 global 关键字声明</span><br><span class="line">print(num)</span><br><span class="line">num =  123</span><br><span class="line">print(num)</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  outer():</span><br><span class="line">num =  10</span><br><span class="line">def  inner():</span><br><span class="line">nonlocal num # nonlocal关键字声明</span><br><span class="line">num =  100</span><br><span class="line">print(num)</span><br><span class="line">inner()</span><br><span class="line">print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">def  outer():</span><br><span class="line">num =  10</span><br><span class="line">def  inner():</span><br><span class="line">nonlocal num # nonlocal关键字声明</span><br><span class="line">num =  100</span><br><span class="line">print(num)</span><br><span class="line">inner()</span><br><span class="line">print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p><p>另外有一种特殊情况，假设下面这段代码被运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">a =  10</span><br><span class="line">def  test():</span><br><span class="line">a = a +  1</span><br><span class="line">print(a)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">589</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">test</span>()</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">587</span>, <span class="keyword">in</span> <span class="keyword">test</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">UnboundLocalError: <span class="keyword">local</span> <span class="keyword">variable</span> <span class="string">'a'</span> <span class="keyword">referenced</span> <span class="keyword">before</span> assignment</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识6</title>
      <link href="/2018/04/30/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%866/"/>
      <url>/2018/04/30/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%866/</url>
      <content type="html"><![CDATA[<h1 id="1-时间和日期"><a href="#1-时间和日期" class="headerlink" title="1 时间和日期"></a>1 时间和日期</h1><p>Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。<br>Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。<br>时间间隔是以秒为单位的浮点小数。<br>每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。<br>Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">ticks =  time.time()</span><br><span class="line">print (&quot;当前时间戳为:&quot;, ticks)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前时间戳为: <span class="number">1525748174</span>.<span class="number">8730757</span></span><br></pre></td></tr></table></figure></p><p>目前，UNIX和Windows只支持到2038年。</p><a id="more"></a><h2 id="1-1-时间元组"><a href="#1-1-时间元组" class="headerlink" title="1.1 时间元组"></a>1.1 时间元组</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">属性</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">tm_year</td><td style="text-align:center">2008</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">tm_mon</td><td style="text-align:center">1 到 12</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">tm_mday</td><td style="text-align:center">1 到 31</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">tm_hour</td><td style="text-align:center">0 到 23</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">tm_min</td><td style="text-align:center">0 到 59</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">tm_sec</td><td style="text-align:center">0 到 61 (60或61 是闰秒)</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">tm_wday</td><td style="text-align:center">0到6 (0是周一)</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">tm_yday</td><td style="text-align:center">一年中的第几天，1 到 366</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">tm_isdst</td><td style="text-align:center">是否为夏令时，值有：1(夏令时)、0(不是夏令时)、-1(未知)，默认 -1</td></tr></tbody></table><h2 id="1-2-获取当前详细时间"><a href="#1-2-获取当前详细时间" class="headerlink" title="1.2 获取当前详细时间"></a>1.2 获取当前详细时间</h2><p>从返回浮点数的时间辍方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">a =  time.localtime(time.time())</span><br><span class="line">print (&quot;本地时间为 :&quot;, a)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地时间为 : time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=5, <span class="attribute">tm_mday</span>=8, <span class="attribute">tm_hour</span>=11, <span class="attribute">tm_min</span>=17, <span class="attribute">tm_sec</span>=58, <span class="attribute">tm_wday</span>=1, <span class="attribute">tm_yday</span>=128, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure></p><h2 id="1-3-获取格式化时间"><a href="#1-3-获取格式化时间" class="headerlink" title="1.3 获取格式化时间"></a>1.3 获取格式化时间</h2><p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">a =  time.localtime(time.time())</span><br><span class="line">print (&quot;本地时间为 :&quot;, a)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地时间为 : <span class="selector-tag">Tue</span> <span class="selector-tag">May</span>  8 11<span class="selector-pseudo">:32</span><span class="selector-pseudo">:04</span> 2018</span><br></pre></td></tr></table></figure></p><h2 id="1-4-格式化日期"><a href="#1-4-格式化日期" class="headerlink" title="1.4 格式化日期"></a>1.4 格式化日期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 格式化成2018-05-08 11:39:58形式</span><br><span class="line">print (time.strftime(&quot;%Y-%m-%d  %H:%M:%S&quot;, \</span><br><span class="line">time.localtime()))</span><br><span class="line"></span><br><span class="line"># 格式化成Tue May 08 11:39:58 2018形式</span><br><span class="line">print (time.strftime(&quot;%a  %b  %d  %H:%M:%S  %Y&quot;, \</span><br><span class="line">time.localtime()))</span><br><span class="line"># 将格式字符串转换为时间戳</span><br><span class="line">a =  &quot;Tue May 08 11:39:58 2018&quot;</span><br><span class="line">print (time.mktime(time.strptime(a,&quot;%a  %b  %d  \</span><br><span class="line">%H:%M:%S  %Y&quot;)))</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="selector-tag">-05-08</span>  11<span class="selector-pseudo">:44</span><span class="selector-pseudo">:52</span></span><br><span class="line"><span class="selector-tag">Tue</span>  <span class="selector-tag">May</span>  08  11<span class="selector-pseudo">:44</span><span class="selector-pseudo">:52</span>  2018</span><br><span class="line">1525750798<span class="selector-class">.0</span></span><br></pre></td></tr></table></figure></p><p>python中时间日期格式化符号：</p><ul><li>%y 两位数的年份表示（00-99）</li><li>%Y 四位数的年份表示（000-9999）</li><li>%m 月份（01-12）</li><li>%d 月内中的一天（0-31）</li><li>%H 24小时制小时数（0-23）</li><li>%I 12小时制小时数（01-12）</li><li>%M 分钟数（00=59）</li><li>%S 秒（00-59）</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天（001-366）</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数（00-53）星期天为星期的开始</li><li>%w 星期（0-6），星期天为星期的开始</li><li>%W 一年中的星期数（00-53）星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul><h2 id="1-5-获取某月日历"><a href="#1-5-获取某月日历" class="headerlink" title="1.5 获取某月日历"></a>1.5 获取某月日历</h2><p>Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal =  calendar.month(2018, 6)</span><br><span class="line">print (&quot;以下输出2016年1月份的日历:&quot;)</span><br><span class="line">print (cal)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以下输出2016年1月份的日历:</span><br><span class="line">     June 2018</span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">            <span class="number"> 1 </span><span class="number"> 2 </span> 3</span><br><span class="line"><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span><span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 9 </span>10</span><br><span class="line">11<span class="number"> 12 </span>13<span class="number"> 14 </span>15<span class="number"> 16 </span>17</span><br><span class="line">18<span class="number"> 19 </span>20<span class="number"> 21 </span>22<span class="number"> 23 </span>24</span><br><span class="line">25<span class="number"> 26 </span>27<span class="number"> 28 </span>29 30</span><br></pre></td></tr></table></figure></p><h1 id="2-Time-模块"><a href="#2-Time-模块" class="headerlink" title="2 Time 模块"></a>2 Time 模块</h1>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，时间日期 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识5</title>
      <link href="/2018/04/29/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/"/>
      <url>/2018/04/29/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/</url>
      <content type="html"><![CDATA[<h1 id="1-循环语句"><a href="#1-循环语句" class="headerlink" title="1 循环语句"></a>1 循环语句</h1><p>Python中的循环语句有for和while<br>同样需要注意冒号和缩进。另外，在Python中没有do..while循环。</p><h1 id="2-while-循环"><a href="#2-while-循环" class="headerlink" title="2 while 循环"></a>2 while 循环</h1><p>比如使用了 while 来计算 1 到 1000 的总和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">n =  1000</span><br><span class="line">sum  =  0</span><br><span class="line">counter =  1</span><br><span class="line">while counter &lt;= n:</span><br><span class="line">sum  =  sum  + counter</span><br><span class="line">counter +=  1</span><br><span class="line">print(&quot;1 到 %d 之和为: %d&quot;  % (n,sum))</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>到 <span class="number">1000</span> 之和为: <span class="number">500500</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="2-1-无线循环"><a href="#2-1-无线循环" class="headerlink" title="2.1 无线循环"></a>2.1 无线循环</h2><p>通过设置条件表达式永远为true来实现无限循环，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">var,cnt=  1,0</span><br><span class="line">num =  int(input(&quot;输入一个数字 :&quot;))</span><br><span class="line"></span><br><span class="line">while var ==  1 : # 表达式永远为 true</span><br><span class="line">print (cnt,&quot;你输入的数字是: &quot;, num)</span><br><span class="line">cnt = cnt+1</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入一个数字  :666</span><br><span class="line">...</span><br><span class="line"><span class="attribute">176736 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176737 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176738 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176739 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176740 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176741 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176742 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176743 你输入的数字是</span>:  666</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p><h2 id="2-2-while-循环使用-else-语句"><a href="#2-2-while-循环使用-else-语句" class="headerlink" title="2.2 while 循环使用 else 语句"></a>2.2 while 循环使用 else 语句</h2><p>在 while … else 在条件语句为 false 时执行 else 的语句块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">count =  0</span><br><span class="line">while count &lt;  5:</span><br><span class="line">print (count, &quot; 小于 5&quot;)</span><br><span class="line">count = count +  1</span><br><span class="line">else:</span><br><span class="line">print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span> 大于或等于 <span class="number">5</span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-简单语句组"><a href="#2-3-简单语句组" class="headerlink" title="2.3 简单语句组"></a>2.3 简单语句组</h2><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">flag =  1</span><br><span class="line">while (flag): print (&apos;无限死循环~&apos;)</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="2-4-for语句"><a href="#2-4-for语句" class="headerlink" title="2.4 for语句"></a>2.4 for语句</h2><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">sites =  [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Amazon&quot;,&quot;Taobao&quot;]</span><br><span class="line">for site in sites:</span><br><span class="line">if site ==  &quot;Taobao&quot;:</span><br><span class="line">print(&quot;马云爸爸!&quot;)</span><br><span class="line">break</span><br><span class="line">print(&quot;循环数据 &quot;  + site)</span><br><span class="line">else:</span><br><span class="line">print(&quot;没有循环数据!&quot;)</span><br><span class="line">print(&quot;完成循环!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">循环数据 Baidu</span><br><span class="line">循环数据 Google</span><br><span class="line">循环数据 Amazon</span><br><span class="line">马云爸爸!</span><br><span class="line">完成循环!</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="2-5-range-函数"><a href="#2-5-range-函数" class="headerlink" title="2.5 range() 函数"></a>2.5 range() 函数</h2><p>如果你需要遍历数字序列，可以使用内置range()函数，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for i in  range(5):</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(5,9) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(0, 10, 3) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(-10, -100, -30) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">sites =  [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Amazon&quot;,&quot;Taobao&quot;]</span><br><span class="line">for sites in  range(len(a)):</span><br><span class="line">print(i, a[i])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">0 Baidu</span><br><span class="line">1 Google</span><br><span class="line">2 Amazon</span><br><span class="line">3 Taobao</span><br></pre></td></tr></table></figure></p><h2 id="2-6-break和continue语句及循环中的else子句"><a href="#2-6-break和continue语句及循环中的else子句" class="headerlink" title="2.6 break和continue语句及循环中的else子句"></a>2.6 break和continue语句及循环中的else子句</h2><p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for letter in  &apos;orange&apos;: # 第一个实例</span><br><span class="line">if letter ==  &apos;n&apos;:</span><br><span class="line">break</span><br><span class="line">print (&apos;当前字母为 :&apos;, letter)</span><br><span class="line"></span><br><span class="line">var =  10  # 第二个实例</span><br><span class="line">while var &gt;  0:</span><br><span class="line">print (&apos;当期变量值为 :&apos;, var)</span><br><span class="line">var = var -1</span><br><span class="line">if var ==  5:</span><br><span class="line">break</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前字母为 : <span class="type">r</span></span><br><span class="line">当前字母为 : <span class="type">a</span></span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for letter in  &apos;orange&apos;: # 第一个实例</span><br><span class="line">if letter ==  &apos;n&apos;:</span><br><span class="line">continue</span><br><span class="line">print (&apos;当前字母为 :&apos;, letter)</span><br><span class="line">var =  10  # 第二个实例</span><br><span class="line">while var &gt;  0:</span><br><span class="line">print (&apos;当期变量值为 :&apos;, var)</span><br><span class="line">var = var -1</span><br><span class="line">if var ==  5:</span><br><span class="line">continue</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前字母为 : <span class="type">r</span></span><br><span class="line">当前字母为 : <span class="type">a</span></span><br><span class="line">当前字母为 : <span class="type">g</span></span><br><span class="line">当前字母为 : <span class="type">e</span></span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">当期变量值为 : 5</span><br><span class="line">当期变量值为 : 4</span><br><span class="line">当期变量值为 : 3</span><br><span class="line">当期变量值为 : 2</span><br><span class="line">当期变量值为 : 1</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p><h2 id="2-7-pass语句"><a href="#2-7-pass语句" class="headerlink" title="2.7 pass语句"></a>2.7 pass语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。<br>pass 不做任何事情，一般用做占位语句，例如：<br>在 C/C++ 中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) </span><br><span class="line">; <span class="comment">//do nothing </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在Python中则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if  true: </span><br><span class="line">    pass #do  nothing  </span><br><span class="line">else: </span><br><span class="line">    #do something</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，循环语句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识4</title>
      <link href="/2018/04/27/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864/"/>
      <url>/2018/04/27/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864/</url>
      <content type="html"><![CDATA[<h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1 斐波那契数列"></a>1 斐波那契数列</h1><p>在 Python3 中赋值符号两侧可以同时对应的多个变量赋值，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b,c,d =  1,2,3,4</span><br><span class="line">print(&quot;a:&quot;,a)</span><br><span class="line">print(&quot;b:&quot;,b)</span><br><span class="line">print(&quot;c:&quot;,c)</span><br><span class="line">print(&quot;d:&quot;,d)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">a:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">b:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">c:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">d:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>编写斐波那契数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b = 0,1</span><br><span class="line">while b&lt;20:</span><br><span class="line">    print(b)</span><br><span class="line">    a,b = b,a+b</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure></p><p>如果需要在同一行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b = 0,1</span><br><span class="line">while b&lt;20:</span><br><span class="line">    print(b,end=&quot; &quot;)</span><br><span class="line">    a,b = b,a+b</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span></span><br></pre></td></tr></table></figure></p><h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2 条件语句"></a>2 条件语句</h1><h2 id="2-1-if语句"><a href="#2-1-if语句" class="headerlink" title="2.1 if语句"></a>2.1 if语句</h2><p>Python中if语句的一般形式如下所示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  co<span class="symbol">ndition_1</span>: </span><br><span class="line">    stateme<span class="symbol">nt_block_1</span>  </span><br><span class="line">elif  co<span class="symbol">ndition_2</span>: </span><br><span class="line">    stateme<span class="symbol">nt_block_2</span>  </span><br><span class="line">else: </span><br><span class="line">    stateme<span class="symbol">nt_block_3</span></span><br></pre></td></tr></table></figure></p><ul><li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li><li>如果 “condition_1” 为False，将判断 “condition_2”</li><li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li><li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li></ul><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><p><strong>注意：</strong></p><ul><li>1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。</li><li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>3、在Python中没有switch – case语句。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">age =  int(input(&quot;请输入你家狗狗的年龄: &quot;))</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">if age &lt; 0  or age == 0:</span><br><span class="line">print(&quot;你是在逗我吧!&quot;)</span><br><span class="line">elif age ==  1:</span><br><span class="line">print(&quot;相当于 14 岁的人。&quot;)</span><br><span class="line">elif age ==  2:</span><br><span class="line">print(&quot;相当于 22 岁的人。&quot;)</span><br><span class="line">elif age &gt;  2:</span><br><span class="line">human =  22  + (age -2)*5</span><br><span class="line">print(&quot;对应人类年龄: &quot;, human)</span><br><span class="line">### 退出提示</span><br><span class="line">input(&quot;点击 enter 键退出&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入你家狗狗的年龄: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">你是在逗我吧!</span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入你家狗狗的年龄: 1</span></span><br><span class="line"></span><br><span class="line">相当于 14 岁的人。</span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入你家狗狗的年龄: 15</span></span><br><span class="line"></span><br><span class="line"><span class="section">对应人类年龄:  87</span></span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td></tr><tr><td><code>==</code></td><td>等于，比较对象是否相等</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table><p>数字的比较运算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">number =  7</span><br><span class="line">guess =  -1</span><br><span class="line">print(&quot;数字猜谜游戏!&quot;)</span><br><span class="line">while guess != number:</span><br><span class="line">guess =  int(input(&quot;请输入你猜的数字：&quot;))</span><br><span class="line">if guess == number:</span><br><span class="line">print(&quot;恭喜，你猜对了！&quot;)</span><br><span class="line">elif guess &lt; number:</span><br><span class="line">print(&quot;猜的数字小了...&quot;)</span><br><span class="line">elif guess &gt; number:</span><br><span class="line">print(&quot;猜的数字大了...&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数字猜谜游戏!</span><br><span class="line">请输入你猜的数字：<span class="number">1</span></span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：<span class="number">6</span></span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：<span class="number">12</span></span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：<span class="number">8</span></span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：<span class="number">7</span></span><br><span class="line">恭喜，你猜对了！</span><br></pre></td></tr></table></figure></p><h2 id="2-2-if嵌套"><a href="#2-2-if嵌套" class="headerlink" title="2.2 if嵌套"></a>2.2 if嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式1:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式2:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式3:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式4:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">num</span>=int(input("输入一个数字："))</span><br><span class="line"><span class="keyword">if</span> num%<span class="attribute">2</span>==0:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="attribute">3</span>==0:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 2 和 3"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 2，但不能整除 3"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="attribute">3</span>==0:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 3，但不能整除 2"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="builtin-name">print</span>  (<span class="string">"你输入的数字不能整除 2 和 3"</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个数字：<span class="number">9</span></span><br><span class="line">你输入的数字可以整除 <span class="number">3</span>，但不能整除 <span class="number">2</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，斐波那契 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识3</title>
      <link href="/2018/04/26/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/"/>
      <url>/2018/04/26/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-字典"><a href="#1-Python3-字典" class="headerlink" title="1 Python3 字典"></a>1 Python3 字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure></p><p>而这一特性与 Json 十分相似，例如某个 Json对象:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">a</span>:<span class="number">666</span>,<span class="attr">b</span>:<span class="string">"Hello"</span>,<span class="attr">c</span>:<span class="string">"World"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>某个Python3字典例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="1-1-访问字典里的值"><a href="#1-1-访问字典里的值" class="headerlink" title="1.1 访问字典里的值"></a>1.1 访问字典里的值</h2><p>访问字典里的值，只需要找到对应的键就可以了，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Mayun&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125; </span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;]) </span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  <span class="symbol">Mayun</span></span><br><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">7</span></span><br></pre></td></tr></table></figure></p><h2 id="1-2-修改字典的值"><a href="#1-2-修改字典的值" class="headerlink" title="1.2 修改字典的值"></a>1.2 修改字典的值</h2><p>向字典添加新内容的方法是增加新的键/值对，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line"></span><br><span class="line">dict[&apos;Age&apos;]  =  22; # 更新 Age</span><br><span class="line">dict[&apos;School&apos;]  =  &quot;ABC&quot;  # 添加信息</span><br><span class="line"></span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">22</span></span><br><span class="line">dict[<span class="string">'School'</span>]:  <span class="symbol">ABC</span></span><br></pre></td></tr></table></figure></p><h2 id="1-3-删除字典元素"><a href="#1-3-删除字典元素" class="headerlink" title="1.3 删除字典元素"></a>1.3 删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line"></span><br><span class="line">del  dict[&apos;Name&apos;]  # 删除键 &apos;Name&apos;</span><br><span class="line">dict.clear()  # 清空字典,字典还存在</span><br><span class="line">del  dict  # 删除字典，字典不存在</span><br><span class="line"></span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">189</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">TypeError: <span class="string">'type'</span> <span class="keyword">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure></p><h2 id="1-4-字典的特性"><a href="#1-4-字典的特性" class="headerlink" title="1.4 字典的特性"></a>1.4 字典的特性</h2><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><ul><li><p>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Name&apos;: &apos;Mike&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure><p>  输出结果：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  <span class="symbol">Mike</span></span><br></pre></td></tr></table></figure></li><li><p>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict  = &#123;[&apos;Name&apos;]: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Name&apos;: &apos;Mike&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure><p>  输出结果：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">183</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Jack'</span>, <span class="string">'Age'</span>: <span class="number">16</span>, <span class="string">'Name'</span>: <span class="string">'Mike'</span>&#125;</span><br><span class="line">TypeError: unhashable <span class="keyword">type</span>: <span class="string">'list'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5-字典内置函数"><a href="#1-5-字典内置函数" class="headerlink" title="1.5 字典内置函数"></a>1.5 字典内置函数</h2><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1</td><td>radiansdict.clear() 删除字典内所有元素</td></tr><tr><td>2</td><td>radiansdict.copy() 返回一个字典的浅复制</td></tr><tr><td>3</td><td>radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td>4</td><td>radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td>5</td><td>key in dict 如果键在字典dict里返回true，否则返回false</td></tr><tr><td>6</td><td>radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td>7</td><td>radiansdict.keys() 以列表返回一个字典所有的键</td></tr><tr><td>8</td><td>radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>9</td><td>radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里</td></tr><tr><td>10</td><td>radiansdict.values() 以列表返回字典中的所有值</td></tr><tr><td>11</td><td>pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>12</td><td>popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对)。</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_indev的探究</title>
      <link href="/2018/04/23/lv_indev%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/04/23/lv_indev%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-indev的作用"><a href="#1-lv-indev的作用" class="headerlink" title="1 lv_indev的作用"></a>1 lv_indev的作用</h1><p>在LittlevGL的全局设置中可以看到(如下图)，lv_indev的作用是定义获取输入操作的周期，单位为毫秒。<br><img src="http://mypic666.test.upcdn.net/20180427145443.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><ul><li>当<code>#define  LV_INDEV_READ_PERIOD  10</code>的时候，在屏幕上滑动列表，感觉滑动的效果会比较流畅</li><li>当<code>#define  LV_INDEV_READ_PERIOD  50</code>的时候，在屏幕上滑动列表，感觉滑动的效果有明显的卡顿感</li></ul><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_obj.c 文件中可以找到如下定义，lv_indev的启动入口即是从这里开始<br><img src="http://mypic666.test.upcdn.net/20180427161531.png" alt=""></p><a id="more"></a><p>在 lv_indev.c 中可以看到 <code>lv_indev_init()</code>模块的初始化其实是创建了一个任务<br><img src="http://mypic666.test.upcdn.net/20180502180321.png" alt=""></p><p>任务唤醒周期参数<code>LV_INDEV_READ_PERIOD</code> 正好就是全局设置中设置好的宏定义。任务中调用的模块<code>indev_proc_task</code>如下所示<br><img src="http://mypic666.test.upcdn.net/20180502202334.png" alt=""></p><p>可以看到首先是通过<code>indev_proc_task</code>来获取下一个输入操作的指针，<br>如果指针存在，就在载入这个输入操作之前重置其句柄，随后判断如果输入操作没有被禁用，就去读这个输入操作的类型，是长按、点击、组合键盘、还是按钮的类型，并且读取输入操作获取的数据，最后结束判断后再将句柄重置一遍，再获取下一个输入操作的指针，并且标记当前输入活动为空。</p><p>下面是代码是指向下一个输入设备的操作<br><img src="http://mypic666.test.upcdn.net/20180502215426.png" alt=""><br>可以看到，如果没有指定的句柄，就直接返回输入操作的列表，否则就返回句柄中的下一个输入操作。</p><p>而<code>indev_list</code>的值是通过<code>lv_indev_drv_register</code>来获取的的，如下图所示，其实也就是一个带有输入操作参数的结构体，然后其指针被付给了<code>indev_list</code><br><img src="http://mypic666.test.upcdn.net/20180502220704.png" alt=""></p><p>而这个<code>lv_indev_drv_register</code>在 <code>main</code> 函数中被加载<br><img src="http://mypic666.test.upcdn.net/20180502222317.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，设备输入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识2</title>
      <link href="/2018/04/20/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"/>
      <url>/2018/04/20/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-列表"><a href="#1-Python3-列表" class="headerlink" title="1 Python3 列表"></a>1 Python3 列表</h1><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。</p><h2 id="1-1-访问列表中的值"><a href="#1-1-访问列表中的值" class="headerlink" title="1.1 访问列表中的值"></a>1.1 访问列表中的值</h2><p>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  </span><br><span class="line">list1 =  [&apos;Aliyun&apos;, &apos;Baidu&apos;, 1997, 2000];</span><br><span class="line">list2 =  [1, 2, 3, 4, 5, 6, 7  ];</span><br><span class="line">print (&quot;list1[0]: &quot;, list1[0])</span><br><span class="line">print (&quot;list2[1:5]: &quot;, list2[1:5])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1<span class="string">[0]</span>:  Aliyun</span><br><span class="line">list2<span class="string">[1:5]</span>:  <span class="string">[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="1-2-更新列表"><a href="#1-2-更新列表" class="headerlink" title="1.2 更新列表"></a>1.2 更新列表</h2><p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  </span><br><span class="line">list  =  [&apos;Alibaba&apos;, &apos;Baidu&apos;, 2015, 2016]</span><br><span class="line">print (&quot;第二个元素为 : &quot;, list[1])</span><br><span class="line">print (&quot;第三个元素为 : &quot;, list[2])</span><br><span class="line">list[2]  =  2001</span><br><span class="line">print (&quot;更新后的第三个元素为 : &quot;, list[2])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二个元素为 :  <span class="type">Baidu</span></span><br><span class="line">第三个元素为 :  2015</span><br><span class="line">更新后的第三个元素为 :  2001</span><br></pre></td></tr></table></figure></p><h2 id="1-3-删除列表元素"><a href="#1-3-删除列表元素" class="headerlink" title="1.3 删除列表元素"></a>1.3 删除列表元素</h2><p>可以使用 del 语句来删除列表的的元素，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">list  =  [<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2015</span>, <span class="number">2016</span>]</span><br><span class="line"><span class="keyword">print</span> (list)</span><br><span class="line"><span class="keyword">del</span>  list[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"删除第三个元素后 : "</span>, list)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2015</span>, <span class="number">2016</span>]</span><br><span class="line">删除第三个元素后 :  [<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2016</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-4-列表脚本操作符"><a href="#1-4-列表脚本操作符" class="headerlink" title="1.4 列表脚本操作符"></a>1.4 列表脚本操作符</h2><p>列表对 <code>+</code>和 <code>*</code> 的操作符与字符串相似。<code>+</code> 号用于组合列表，<code>*</code>号用于重复列表，<code>in</code>判断元素是否存在于列表中，<code>for</code>起迭代作用<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">print(len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  +  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print([<span class="string">'Fuck!'</span>]  *  <span class="number">6</span>)</span><br><span class="line">print(<span class="number">3</span>  <span class="keyword">in</span>  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span>  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]: print(x, end=<span class="string">""</span>)<span class="comment">#end起不换行的作用</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">['Fuck!', 'Fuck!', 'Fuck!', 'Fuck!', 'Fuck!', 'Fuck!']</span><br><span class="line">True</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="1-5-列表截取与拼接"><a href="#1-5-列表截取与拼接" class="headerlink" title="1.5 列表截取与拼接"></a>1.5 列表截取与拼接</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">L=[<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="string">'Samsung'</span>]</span><br><span class="line">print(L[<span class="number">2</span>])</span><br><span class="line">print(L[<span class="number">-2</span>])<span class="comment">#从右侧开始读取倒数第二个元素</span></span><br><span class="line">print(L[<span class="number">-3</span>])</span><br><span class="line">print(L[<span class="number">1</span>:])<span class="comment">#输出从第二个元素开始后的所有元素</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Samsung</span><br><span class="line">Apple</span><br><span class="line">Sony</span><br><span class="line">['Apple', 'Samsung']</span><br></pre></td></tr></table></figure></p><h2 id="1-6-嵌套列表"><a href="#1-6-嵌套列表" class="headerlink" title="1.6 嵌套列表"></a>1.6 嵌套列表</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x = [a, n]</span><br><span class="line">print(x)</span><br><span class="line">print(x[<span class="number">0</span>])</span><br><span class="line">print(x[<span class="number">0</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><h2 id="1-7-列表函数-amp-方法"><a href="#1-7-列表函数-amp-方法" class="headerlink" title="1.7 列表函数&amp;方法"></a>1.7 列表函数&amp;方法</h2><p>Python包含以下列表函数:</p><p>list参数 均为列表名称</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td>len(list) 列表元素个数</td></tr><tr><td>2</td><td>max(list) 返回列表元素最大值</td></tr><tr><td>3</td><td>min(list) 返回列表元素最小值</td></tr><tr><td>4</td><td>list(tuple) 将列表转换为元组。</td></tr></tbody></table><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td>list.append(obj) 在列表末尾添加新的对象</td></tr><tr><td>2</td><td>list.count(obj) 统计某个元素在列表中出现的次数</td></tr><tr><td>3</td><td>list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>4</td><td>list.index(obj)] 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>5</td><td>list.insert(index, obj) 将对象插入列表</td></tr><tr><td>6</td><td>list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>7</td><td>list.remove(obj) 移除列表中某个值的第一个匹配项</td></tr><tr><td>8</td><td>list.reverse() 反向列表中元素</td></tr><tr><td>9</td><td>list.sort([func]) 对原列表进行排序</td></tr><tr><td>10</td><td>list.clear() 清空列表</td></tr><tr><td>11</td><td>list.copy() 复制列表</td></tr></tbody></table><h1 id="2-Python3-元组"><a href="#2-Python3-元组" class="headerlink" title="2 Python3 元组"></a>2 Python3 元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。<br>元组使用<strong>小括号</strong>，列表使用<strong>方括号</strong>。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>);</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> );</span><br><span class="line">tup3 =  <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>; <span class="comment"># 不需要括号也可以</span></span><br><span class="line">print(type(tup3))</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="number">50</span>) </span><br><span class="line">print(type(tup1))     <span class="comment"># 不加逗号，类型为整型 </span></span><br><span class="line">tup1 = (<span class="number">50</span>,) </span><br><span class="line">print(type(tup1))     <span class="comment"># 加上逗号，类型为元组</span></span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt; </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-1-访问元组"><a href="#2-1-访问元组" class="headerlink" title="2.1 访问元组"></a>2.1 访问元组</h2><p>元组可以使用下标索引来访问元组中的值<br>例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="number">2015</span>, <span class="number">2016</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup2[1:5]: "</span>, tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tup1</span><span class="selector-attr">[0]</span>:  <span class="selector-tag">Sony</span></span><br><span class="line"><span class="selector-tag">tup2</span><span class="selector-attr">[1:5]</span>:  (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-1-修改元组"><a href="#2-1-修改元组" class="headerlink" title="2.1 修改元组"></a>2.1 修改元组</h2><p><strong>元组中的元素值是不允许修改的</strong>，但我们可以对元组进行连接组合<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>);</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2;</span><br><span class="line"><span class="keyword">print</span> (tup3)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">12</span>, <span class="number">34.56</span>, <span class="symbol">'abc</span>', <span class="symbol">'xyz</span>')</span><br></pre></td></tr></table></figure></p><h2 id="2-2-删除元组"><a href="#2-2-删除元组" class="headerlink" title="2.2 删除元组"></a>2.2 删除元组</h2><p><strong>元组中的元素值是不允许删除的</strong>，但我们可以使用del语句来删除整个元组例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup0 = (<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="number">2015</span>, <span class="number">2016</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (tup0)</span><br><span class="line"><span class="keyword">del</span> tup0;</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"删除后的元组 tup0 : "</span>)</span><br><span class="line"><span class="keyword">print</span> (tup0)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除后的元组 tup0 :</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print (tup0)</span><br><span class="line">NameError: <span class="keyword">name</span> <span class="string">'tup0'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p><h2 id="2-3-元组运算符"><a href="#2-3-元组运算符" class="headerlink" title="2.3 元组运算符"></a>2.3 元组运算符</h2><p>列表对 <code>+</code>和 <code>*</code> 的操作符与字符串相似。<code>+</code> 号用于组合列表，<code>*</code>号用于重复列表，<code>in</code>判断元素是否存在于列表中，<code>for</code>起迭代作用<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">print(len((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">print((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">print((<span class="string">'Fuck!'</span>) *  <span class="number">6</span>)</span><br><span class="line">print(<span class="number">3</span>  <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>): print(x, end=<span class="string">""</span>)<span class="comment">#end起不换行的作用</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">Fuck!Fuck!Fuck!Fuck!Fuck!Fuck!</span><br><span class="line">True</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></p><h2 id="2-4-元组索引，截取"><a href="#2-4-元组索引，截取" class="headerlink" title="2.4 元组索引，截取"></a>2.4 元组索引，截取</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">L=(<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="string">'Samsung'</span>)</span><br><span class="line">print(L[<span class="number">2</span>])</span><br><span class="line">print(L[<span class="number">-2</span>])<span class="comment">#从右侧开始读取倒数第二个元素</span></span><br><span class="line">print(L[<span class="number">-3</span>])</span><br><span class="line">print(L[<span class="number">1</span>:])<span class="comment">#输出从第二个元素开始后的所有元素</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Samsung</span></span><br><span class="line"><span class="selector-tag">Apple</span></span><br><span class="line"><span class="selector-tag">Sony</span></span><br><span class="line">(<span class="string">'Apple'</span>, <span class="string">'Samsung'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-5-元组内置函数"><a href="#2-5-元组内置函数" class="headerlink" title="2.5 元组内置函数"></a>2.5 元组内置函数</h2><p>tuple参数 均为列表名称</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td>len(tuple) 列表元素个数</td></tr><tr><td>2</td><td>max(tuple) 返回列表元素最大值</td></tr><tr><td>3</td><td>min(tuple) 返回列表元素最小值</td></tr><tr><td>4</td><td>tuple(list) 将列表转换为元组。</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识1</title>
      <link href="/2018/04/17/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/"/>
      <url>/2018/04/17/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
      <content type="html"><![CDATA[<h1 id="1-Hello-world"><a href="#1-Hello-world" class="headerlink" title="1 Hello world"></a>1 Hello world</h1><p>以下是Python3打印输出的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">print(&quot;Hello, World!&quot;);</span><br></pre></td></tr></table></figure></p><p>对于第一行代码 <code>#!/usr/bin/env python</code> </p><ul><li>如在终端果使用 <code>python test.py</code> 调用，则第一行代码被忽略，相当于注释。</li><li>如果在终端使用 <code>./test.py</code> 调用，则第一行代码这是指定解释器的类型。</li><li>第一行代码其实还可以写成 <code>#!/usr/bin/python</code> ，而这样是告诉操作系统直接调用/usr/bin下的python解释器，但是如果加上了<code>env</code>相当于告诉操作系统先去环境变量中找python的路径，再调用路径下的解释器，所以不加<code>env</code>则相当于把路径写死了，一般推荐加上<code>env</code>的写法。</li></ul><a id="more"></a><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2 基础知识"></a>2 基础知识</h1><h2 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1 编码"></a>2.1 编码</h2><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。<br>如果需要不同的编码，如使用GBK编码则在文件开头插入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: gbk -*-</span><br></pre></td></tr></table></figure></p><h2 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h2><ul><li>第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li><strong>*标识符对大小写敏感</strong>。</li><li>Python 3 中，允许非 ASCII 标识符。</li></ul><h2 id="2-3-保留字"><a href="#2-3-保留字" class="headerlink" title="2.3 保留字"></a>2.3 保留字</h2><p><code>keyword.kwlist</code>是python的标准库提供的一个模块，可输出当前版本所有保留关键字。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import keyword</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-4-分号"><a href="#2-4-分号" class="headerlink" title="2.4 分号"></a>2.4 分号</h2><p>Python主要是靠换行来区分代码语句，一般来说<code>；</code>可加可不加，如果一行有多个代码语句，就要加上<code>；</code></p><h2 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h2><p>注释可以使用 <code>#</code> 、<code>&#39;&#39;&#39;</code>、<code>&quot;&quot;&quot;</code> ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#注释1</span></span><br><span class="line"><span class="comment">#注释2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">注释3</span></span><br><span class="line"><span class="string">注释4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注释5</span></span><br><span class="line"><span class="string">注释6</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"Hello Python"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-6-行与缩进"><a href="#2-6-行与缩进" class="headerlink" title="2.6 行与缩进"></a>2.6 行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号<code>{}</code> 。</p><p>以下代码没问题<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第5行缩进不对就会报错<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"> <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第3行缩进不对也会报错<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第4、5行缩进相同不会报错，但是第4、5行缩进不能与第3行相同<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line">  <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠<code>\</code>来实现多行语句，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum = a + \</span><br><span class="line">      b + \</span><br><span class="line">      c</span><br></pre></td></tr></table></figure></p><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠<code>\</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,</span><br><span class="line"><span class="string">'d'</span>,<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="2-7-数字类型"><a href="#2-7-数字类型" class="headerlink" title="2.7 数字类型"></a>2.7 数字类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h2 id="2-8-字符串"><a href="#2-8-字符串" class="headerlink" title="2.8 字符串"></a>2.8 字符串</h2><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘\’</li><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'字符串'</span> </span><br><span class="line">sentence = <span class="string">"这是一个句子。"</span> </span><br><span class="line">paragraph = <span class="string">"""这是一个段落， </span></span><br><span class="line"><span class="string">可以由多行组成"""</span></span><br></pre></td></tr></table></figure></li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">str=<span class="string">'Helloa'</span>  </span><br><span class="line">print(str)       <span class="comment"># 输出字符串 </span></span><br><span class="line">print(str[<span class="number">0</span>:<span class="number">-1</span>]) <span class="comment"># 输出第一个到倒数第二个的所有字符 </span></span><br><span class="line">print(str[<span class="number">0</span>])        <span class="comment"># 输出字符串第一个字符 </span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>])    <span class="comment"># 输出从第三个开始到第五个的字符 </span></span><br><span class="line">print(str[<span class="number">2</span>:])     <span class="comment"># 输出从第三个开始的后的所有字符 </span></span><br><span class="line">print(str * <span class="number">2</span>)     <span class="comment"># 输出字符串两次 </span></span><br><span class="line">print(str + <span class="string">'你好'</span>)     <span class="comment"># 连接字符串  </span></span><br><span class="line">print(<span class="string">'------------------------------'</span>) </span><br><span class="line">print(<span class="string">'hello\nrunoob'</span>)    <span class="comment"># 使用反斜杠(\)+n转义特殊字符 </span></span><br><span class="line">print(<span class="string">r'hello\nrunoob'</span>)   </span><br><span class="line"><span class="comment">#在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure></p><p>输出结果为：</p><pre><code>HelloaHelloHllolloaHelloaHelloaHelloa你好------------------------------helloareyouokhello\nareyouok</code></pre><h2 id="2-9-空行"><a href="#2-9-空行" class="headerlink" title="2.9  空行"></a>2.9  空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。<br>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。<br><strong>记住：</strong>空行也是程序代码的一部分。</p><h2 id="2-10-用户输入"><a href="#2-10-用户输入" class="headerlink" title="2.10 用户输入"></a>2.10 用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line">input(<span class="string">"\n\n按下 enter 键后退出。"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-11-多个语句构成代码组"><a href="#2-11-多个语句构成代码组" class="headerlink" title="2.11 多个语句构成代码组"></a>2.11 多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :     </span><br><span class="line">suite </span><br><span class="line"><span class="keyword">elif</span> expression :     </span><br><span class="line">suite  </span><br><span class="line"><span class="keyword">else</span> :     </span><br><span class="line">suite</span><br></pre></td></tr></table></figure></p><h2 id="2-12-Print-输出"><a href="#2-12-Print-输出" class="headerlink" title="2.12 Print 输出"></a>2.12 Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=””</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line">x=<span class="string">"a"</span> </span><br><span class="line">y=<span class="string">"b"</span> </span><br><span class="line"><span class="comment"># 换行输出 </span></span><br><span class="line">print( x ) </span><br><span class="line">print( y )  </span><br><span class="line">print(<span class="string">'---------'</span>) <span class="comment"># 不换行输出 </span></span><br><span class="line">print( x, end=<span class="string">" "</span> ) </span><br><span class="line">print( y, end=<span class="string">" "</span> ) </span><br><span class="line">print()</span><br></pre></td></tr></table></figure></p><p> 执行后为：<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> </span><br><span class="line"><span class="selector-tag">b</span> --------- </span><br><span class="line"><span class="selector-tag">a</span> b</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探究Lv_group</title>
      <link href="/2018/04/15/%E6%8E%A2%E7%A9%B6lv_group%E6%96%87%E4%BB%B6/"/>
      <url>/2018/04/15/%E6%8E%A2%E7%A9%B6lv_group%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-group的作用"><a href="#1-lv-group的作用" class="headerlink" title="1 lv_group的作用"></a>1 lv_group的作用</h1><p>在LittlevGL的全局设置中可以看到(如下图)，lv_group是keyboards的扩展功能。<br><img src="http://mypic666.test.upcdn.net/20180424153733.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>在演示程序中可以看到，通过“Next”按键可以控制群对象中的对象之间的切换，类似于电脑上的“Tab键”控制窗口上的菜单之间的切换<br><img src="http://mypic666.test.upcdn.net/20180424164342.png" alt=""></p><a id="more"></a><p><img src="http://mypic666.test.upcdn.net/20180424224107.png" alt=""><br><img src="http://mypic666.test.upcdn.net/20180424224141.png" alt=""></p><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>可以在演示程序的主初始化模块中看到其创建了一个群对象</p><p><img src="http://mypic666.test.upcdn.net/20180424170731.png" alt=""></p><p>并且在群对象中加入了子对象</p><p><img src="http://mypic666.test.upcdn.net/20180424172848.png" alt=""></p><p>以此实现了多个子对象组件成了群对象</p><h1 id="4-程序"><a href="#4-程序" class="headerlink" title="4 程序"></a>4 程序</h1><p>下面是群对象的结构体，可以看到第一个就是预先定义的链表结构体</p><p><img src="http://mypic666.test.upcdn.net/20180424175144.png" alt=""></p><p>通过lv_group群对象创建的源代码可以知道，首先使用了群对象的结构体大小在内存中申请了一部分空间，并且使用群对象结构体中的链表结构体的指针做头结点初始化了一个新的双向链表。</p><p><img src="http://mypic666.test.upcdn.net/20180424174354.png" alt=""></p><p>而在群对象中添加子对象的做法是在一个双向链表的尾部创建一个节点，并且将子对象的指针赋给这个节点。如果当前的结点的后继与当前链表的第一个节点的指针相同，则说明只有一个结点，同时使用<code>lv_group_focus_next()</code>在当前节点的后继创建临时的指针，待下一个子对象的指针的值赋给它。</p><p><img src="http://mypic666.test.upcdn.net/20180424200546.png" alt=""></p><p>这个双向链表的尾部创建一个节点，同样的还有<code>lv_ll_ins_head()</code> ,即在双向链表的头部创建一个结点，与下列代码大致相似。</p><p><img src="http://mypic666.test.upcdn.net/20180424215219.png" alt=""></p><p>这个是将当前的焦点转移到双向链表的下一个结点。</p><p><img src="http://mypic666.test.upcdn.net/20180424201542.png" alt=""></p><p>这样一来，群对象相当与一个链表，各个子对象相当于结点，随意切换到当前子对象的上一个或者下一个子对象都很方便。</p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LittlevGL新版字库图片转换器</title>
      <link href="/2018/04/12/LittlevGL%E6%96%B0%E7%89%88%E5%AD%97%E5%BA%93%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2018/04/12/LittlevGL%E6%96%B0%E7%89%88%E5%AD%97%E5%BA%93%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="1-PHP-环境安装"><a href="#1-PHP-环境安装" class="headerlink" title="1 PHP 环境安装"></a>1 PHP 环境安装</h1><h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h2><p>下面是 PHP7.2 的 windows 64位非安全线程版<br><a href="https://windows.php.net/downloads/releases/php-7.2.4-nts-Win32-VC15-x64.zip" target="_blank" rel="noopener">VC15 x64 Non Thread Safe</a></p><h2 id="1-2-安装环境"><a href="#1-2-安装环境" class="headerlink" title="1.2 安装环境"></a>1.2 安装环境</h2><ul><li><p>将下载后的压缩包解压</p></li><li><p>在系统变量中添加解压后的文件夹的路径，如图所示<br><img src="http://mypic666.test.upcdn.net/20180420205557.png" alt=""></p></li><li><p>变量中php文件夹的根目录与php文件夹中的扩展目录都要添加上去<br><img src="http://mypic666.test.upcdn.net/20180420205842.png" alt=""></p></li><li><p>将php根目录中的 <code>php.ini-development</code> 文件 改名为 <code>php.ini</code></p></li></ul><a id="more"></a><ul><li><p>在 <code>php.ini</code> 文本中找到 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="attribute">extension</span>=gd2</span><br></pre></td></tr></table></figure></li></ul><p>并且将<code>;</code>去掉</p><ul><li>再找到<code>;extension_dir=&quot;tmp&quot;</code>,将<code>;</code>去掉，并将值改为你的php根目录中扩展目录的路径<br>如<code>extension_dir = &quot;C:\php-7.2.4\ext&quot;</code></li><li>在dos中输入 <code>php -v</code> 出现如下内容便是搭建成功<br><img src="http://mypic666.test.upcdn.net/20180420211304.png" alt=""><h1 id="2-字库以及图片的生成"><a href="#2-字库以及图片的生成" class="headerlink" title="2 字库以及图片的生成"></a>2 字库以及图片的生成</h1><h2 id="2-1-获取新版转换工具"><a href="#2-1-获取新版转换工具" class="headerlink" title="2.1 获取新版转换工具"></a>2.1 获取新版转换工具</h2>以下是新版转换工具的地址，将其git下来<br><a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:littlevgl/lv_utils.git`<h2 id="2-2-字库的转换"><a href="#2-2-字库的转换" class="headerlink" title="2.2 字库的转换"></a>2.2 字库的转换</h2></li><li>git下来的目录中可以看到<code>font_conv_core.php</code>这个文件，此文件便是用来转换字库的。</li><li>打开dos并且cd到当前目录中</li><li>将你需要转换的xxx.ttf文件复制到当前目录中</li><li><p>在dos中输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php font_conv_core<span class="selector-class">.php</span> <span class="string">"name=testFONT&amp;font=xxx.ttf&amp;height=20&amp;bpp=4&amp;uni_first=32&amp;uni_last=126&amp;list=%2B-0123456789&amp;built_in=0"</span></span><br></pre></td></tr></table></figure></li><li><p>参数<br><strong>name</strong>：要生成的字库文件的字库名以及其文件名<br><strong>font</strong>：同目录下的tff文件名<br><strong>height</strong>：字体高度<br><strong>bpp</strong>：每像素bit大小（1,2,4,8 四种）<br><strong>uni_first</strong>：选择的unicode开始范围一般为32<br><strong>last_first</strong>：选择的unicode结束范围一般为40869<br><strong>built_in</strong>：是否将其设置为内建字库，即1,2,4,8 bpp都生成<br><strong>list</strong>：输入你要转换的字符如 abcdefg123456你好</p></li><li><p>执行后会在当前目录中生成一个testFONT.c文件，此便是生成的字库</p></li></ul><h2 id="2-3-图片的转换"><a href="#2-3-图片的转换" class="headerlink" title="2.3 图片的转换"></a>2.3 图片的转换</h2><ul><li>在当前目录下可以看到<code>img_conv_core.php</code>文件，此便是图片转换文件。</li><li>将需要转换的图片复制到当前目录，如 xxx.png<br><strong>注意，仅支持BMP，JPG，PNG三种图片格式</strong></li><li><p>将doscd到当前目录下，输入如下命令 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php img_conv_core<span class="selector-class">.php</span> <span class="string">"name=testIMG&amp;img=xxx.png&amp;format=c_array&amp;transp=alpha"</span></span><br></pre></td></tr></table></figure></li><li><p>参数：<br><strong>name</strong>：要生成的文件名<br><strong>img</strong>：当前目录下的源文件名称<br><strong>format</strong>：转换格式，有<code>c_array</code>, <code>bin_rgb332</code>,  <code>bin_rgb565</code>, <code>bin_rgb888</code> 四种，默认是<code>c_array</code><br><strong>transp</strong>：透明设置，有<code>none</code>,<code>alpha</code>,<code>chroma</code>三种，一般选择<code>alpha</code>,默认为<code>none</code></p></li><li>执行后当前目录下生成的testIMG.c文件便是转换后的图片</li></ul>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 字库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_refr的探究</title>
      <link href="/2018/03/21/lv_refr%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/21/lv_refr%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-refr的作用"><a href="#1-lv-refr的作用" class="headerlink" title="1 lv_refr的作用"></a>1 lv_refr的作用</h1><p>在 lv_conf 中可以看到如下宏定义，表示定义屏幕刷新周期的时间，单位为毫秒<br><img src="http://mypic666.test.upcdn.net/20180504232842.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>与 lv_indev 相似，数值越大视觉感受越差</p><ul><li>当<code>#define LV_REFR_PERIOD 1</code>的时候，在屏幕上滑动列表，感觉滑动的效果会比较流畅。</li><li>当<code>#define LV_REFR_PERIOD 40</code>的时候，在屏幕上滑动列表，感觉滑动的效果有明显的卡顿感，如果数值大于<code>LV_INDEV_READ_PERIOD</code>的数值，这会有非常明显的卡顿感。</li></ul><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>可以看到 lv_refr 的初始化函数与 lv_indev 的初始化函数很像，也是创建一个任务，通过周期性的调用任务内的函数来实现屏幕的显示刷新<br><img src="http://mypic666.test.upcdn.net/20180504221318.png" alt=""></p><p>任务中调用的函数如下，首先是获取定时器的消息，并且将刷新缓冲区的内存清零<br><img src="http://mypic666.test.upcdn.net/20180504222026.png" alt=""></p><p>下面是将待刷新的区域加入到缓冲区<br><img src="http://mypic666.test.upcdn.net/20180504230409.png" alt=""></p><p>下面是刷新缓冲区：<br><img src="http://mypic666.test.upcdn.net/20180504231419.png" alt=""></p><p>如果定义了虚拟缓冲区，则会调用下面的函数<br><img src="http://mypic666.test.upcdn.net/20180504232110.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，屏幕刷新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浮点数、定点数</title>
      <link href="/2018/03/21/%E6%B5%AE%E7%82%B9%E6%95%B0%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0/"/>
      <url>/2018/03/21/%E6%B5%AE%E7%82%B9%E6%95%B0%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="什么是定点数"><a href="#什么是定点数" class="headerlink" title="什么是定点数"></a>什么是定点数</h1><h2 id="通俗的解释"><a href="#通俗的解释" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p>​    定点数指小数点在数中的位置是固定不变的，通常有定点整数和定点小数。在对小数点位置作出选择之后，运算中的所有数均应统一为定点整数或定点小数，在运算中不再考虑小数问题。</p><a id="more"></a> <p>​    以人民币为例，我们日常经常说到的如123.45￥，789.34￥等等，默认的情况下，小数点后面有两位小数，即角，分。如果小数点在最高有效位的前面，则这样的数称为纯小数的定点数，如0.12345，0.78934等。如果小数点在最低有效位的后面，则这样的数称为纯整数的定点数，如12345，78934等。</p><h2 id="专业的说法"><a href="#专业的说法" class="headerlink" title="专业的说法"></a>专业的说法</h2><p>​    所谓定点格式，即<strong><em>约定机器中所有数据的小数点位置是固定不变的</em></strong>。通常将定点数据表示成纯小数或纯整数，为了将数表示成纯小数，通常把小数点固定在数值部分的最高位之前；而为了将数表示成纯整数，则把小数点固定在数值部分的最后面，如下图所示：</p><p><img src="http://mypic666.test.upcdn.net/052235097517088.png" alt=""></p><h1 id="什么是浮点数"><a href="#什么是浮点数" class="headerlink" title="什么是浮点数"></a>什么是浮点数</h1><h2 id="通俗的解释-1"><a href="#通俗的解释-1" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p>​    浮点数：一般说来，小数点不固定的数。比较容易的理解方式是，考虑以下我们日常见到的科学记数法，拿我们上面的数字举例，如123.45，可以写成以下几种形式</p><p>如：</p><p>12.345x10^1^</p><p>1.2345 x10^2^</p><p>0.12345 x10^3^</p><p>……</p><p>为了表示一个数，小数点的位置可以变化，即小数点不固定。</p><h2 id="专业的说法-1"><a href="#专业的说法-1" class="headerlink" title="专业的说法"></a>专业的说法</h2><p>​    定点数表示法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大或特别小的数，最终，绝大多数现代的计算机系统采纳了浮点数表达方式，这种表达方式利用科学计数法来表达实数，即用一个尾数(Mantissa，尾数有时也称为<strong><em>有效数字</em></strong>，它实际上是有效数字的非正式说法)，一个基数(Base)，一个指数(Exponent)以及一个表示正负的符号来表达实数，比如123.45用十进制科学计数法可以表示为1.2345x10^2^，其中1.2345为尾数，10为基数，2为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。</p><h1 id="定点数与浮点数的对比"><a href="#定点数与浮点数的对比" class="headerlink" title="定点数与浮点数的对比"></a>定点数与浮点数的对比</h1><p>​    定点表示法运算直观，但数的表示范围较小，不同的数运算时要考虑比例因子的选取，以防止溢出。浮点表示法运算时可以不考虑溢出，但浮点运算，编程较难。要掌握定、浮点数的转换方法及浮点数规格化方法。</p><h2 id="表示的精度与范围不同"><a href="#表示的精度与范围不同" class="headerlink" title="表示的精度与范围不同"></a>表示的精度与范围不同</h2><p>​    例如，我们用4个十进制数来表达一个数字。对于定点数（这里以定点整数为例），我们表示区间[0000，9999]中的任何一个数字，但是如果我们要想表示类似1234.3的数值就无能为力了，因为此时的表示精度为1/10^0^=1；如果采用浮点数来表示（以归整的科学记数法，即小数点前有一位有效位，为例），则可以表示[0.000，9.999]之间的任何一个数字，表示的精度为1/10^3^=0.001，精度比上一种方式提高了很多，但是表示的范围却小了很多。</p><p>​    也就是说，一般的，定点数表示的精度较低，但表示的数值范围较大；而浮点数恰恰相反。</p><h2 id="计算机中运算的效率不同"><a href="#计算机中运算的效率不同" class="headerlink" title="计算机中运算的效率不同"></a>计算机中运算的效率不同</h2><p>​    一般说来，定点数的运算在计算机中实现起来比较简单，效率较高；而浮点数的运算在计算机中实现起来比较复杂，效率相对较低。</p><h2 id="硬件依赖性"><a href="#硬件依赖性" class="headerlink" title="硬件依赖性"></a>硬件依赖性</h2><p>​    一般说来，只要有硬件提供运算的部件，就会提供定点数运算的支持（不知道说的确切否，没有听说过不支持定点数运算的硬件），但不一定支持浮点数运算，如有的很多嵌入式开发板就不提供浮点运算的支持。</p><h1 id="浮点数的存储格式"><a href="#浮点数的存储格式" class="headerlink" title="浮点数的存储格式"></a>浮点数的存储格式</h1><h2 id="IEEE-浮点格式规范"><a href="#IEEE-浮点格式规范" class="headerlink" title="IEEE 浮点格式规范"></a>IEEE 浮点格式规范</h2><p>​    浮点数的小数点是不固定的，如果每个人都按照自己的爱好存储在电脑里，那不就乱套了吗？那么怎么在计算机中存储这种类型的数字呢？象这类古老的问题前人早都为我们做好了相应的规范，无规矩不成方圆吗。我们平时所说的浮点数的存储规范，就是由IEEE指定的，具体的规范文件是：IEEE Standard 754 for Binary Floating-Point Arithmetic。大家可以很容易的从网络上下载到这篇文档。</p><h2 id="单精度浮点"><a href="#单精度浮点" class="headerlink" title="单精度浮点"></a>单精度浮点</h2><p>在c语言中，<strong>单精度（float）数据类型为32bits</strong>，具体的如下图所示：</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102352889.png" alt=""></p><p><strong>整个32bits分三部分，即</strong></p><p>　　Sign：符号位，1 bit，0为正，1为负；</p><p>　　Exponent(bias)：指数部分，8 bits，存储格式为移码存储（后面还会说明），偏移量为127；</p><p>　　Mantissa(fraction)：尾数部分。</p><h2 id="双精度浮点"><a href="#双精度浮点" class="headerlink" title="双精度浮点"></a>双精度浮点</h2><p>　　<strong>对应的双精度（double）类型的格式为：</strong></p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102402031.png" alt=""></p><p>​    同样，64位也被分为了三部分，对照单精度，不用我说就可以理解各个部分的含义了吧？</p><p>　　是不是有点迷糊了，不要怕，理论这个东西最能忽悠人了，看起来很高深，其实也就是个屁大的事，举个例子就很容易明白了。</p><p>举例说明，如3.24x10^3^，则对应的部分为，Sign为0，3为指数部分（注意计算机里面存储的不是3，这里仅仅为了说明），3.24为尾数。我们知道，计算机“笨”的要死，只认识0和1，那么到底一个浮点数值在计算机存储介质中是如何存储的呢？</p><p>例如，我们要想偷窥浮点类型的值4.25在计算机硬盘中存储的庐山真面目，请跟我来：首先把4.25转换成二进制的表达方式，即100.01，在详细点，变成1.0001x2^2^，好了，对号入座把。</p><p>Sign=0;</p><p>Exponent(bias)=2+127=129 （偏移量为127，就是直接加上个127了）；</p><p>Mantissa=1.0001-1.0=0001（规格化后，小数点前总是整数1，全世界人都知道前面是1不是0，所以省略不写了，即尾数部分不包括整数部分；当别人问你，为什么23 bit的尾数部分可以表示24位的精度，知道怎么回答了吧。 靠，什么，没有看懂，再仔细读两便就知道了）。</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102409132.png" alt=""></p><p>​    对照上面的图示，相信你已经看明白了吧？相信你的智商。为了加深认识，再来一个。如果给定你一个二进制数字串</p><p>01000000100010000000000000000000</p><p>并告诉你这是一个float类型的值，让你说出它是老几，知道怎么算了吧？如果不知道，看下面的图，我就不废话解释了。</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102421605.png" alt=""></p><h1 id="浮点定点转换"><a href="#浮点定点转换" class="headerlink" title="浮点定点转换"></a>浮点定点转换</h1><h2 id="Q格式定标法"><a href="#Q格式定标法" class="headerlink" title="Q格式定标法"></a>Q格式定标法</h2><p>​    通过假定小数点位于哪一位(Q)的右侧，从而确定小数的精度，以下为32位数Q定标表格。</p><table><thead><tr><th style="text-align:center">Q表示</th><th style="text-align:center">十进制浮点数表示范围</th><th style="text-align:center">精度</th></tr></thead><tbody><tr><td style="text-align:center">Q=31</td><td style="text-align:center">-1≤x≤0.999 999 999</td><td style="text-align:center">2^(-31)</td></tr><tr><td style="text-align:center">Q=30</td><td style="text-align:center">-2≤x≤1.999 999 999</td><td style="text-align:center">2^(-30)</td></tr><tr><td style="text-align:center">Q=29</td><td style="text-align:center">-4≤x≤3.999 999 998</td><td style="text-align:center">2^(-29)</td></tr><tr><td style="text-align:center">Q=28</td><td style="text-align:center">-8≤x≤7.999 999 996</td><td style="text-align:center">2^(-28)</td></tr><tr><td style="text-align:center">Q=27</td><td style="text-align:center">-16≤x≤15.999 999 993</td><td style="text-align:center">2^(-27)</td></tr><tr><td style="text-align:center">Q=26</td><td style="text-align:center">-32≤x≤31.999 999 985</td><td style="text-align:center">2^(-26)</td></tr><tr><td style="text-align:center">Q=25</td><td style="text-align:center">-64≤x≤63.999 999 970</td><td style="text-align:center">2^(-25)</td></tr><tr><td style="text-align:center">Q=24</td><td style="text-align:center">-128≤x≤127.999 999 940</td><td style="text-align:center">2^(-24)</td></tr><tr><td style="text-align:center">Q=23</td><td style="text-align:center">-256≤x≤255.999 999 981</td><td style="text-align:center">2^(-23)</td></tr><tr><td style="text-align:center">Q=22</td><td style="text-align:center">-512≤x≤511.999 999 762</td><td style="text-align:center">2^(-22)</td></tr><tr><td style="text-align:center">Q=21</td><td style="text-align:center">-1024≤x≤1023.999 999 523</td><td style="text-align:center">2^(-21)</td></tr><tr><td style="text-align:center">Q=20</td><td style="text-align:center">-2048≤x≤2047.999 999 046</td><td style="text-align:center">2^(-20)</td></tr><tr><td style="text-align:center">Q=19</td><td style="text-align:center">-4096≤x≤4095.999 998 093</td><td style="text-align:center">2^(-19)</td></tr><tr><td style="text-align:center">Q=18</td><td style="text-align:center">-8192≤x≤8191.999 996 185</td><td style="text-align:center">2^(-18)</td></tr><tr><td style="text-align:center">Q=17</td><td style="text-align:center">-16384≤x≤16363.999 992 371</td><td style="text-align:center">2^(-17)</td></tr><tr><td style="text-align:center">Q=16</td><td style="text-align:center">-32768≤x≤32767.999 984 741</td><td style="text-align:center">2^(-16)</td></tr><tr><td style="text-align:center">Q=15</td><td style="text-align:center">-65536≤x≤65535.999 969 482</td><td style="text-align:center">2^(-15)</td></tr><tr><td style="text-align:center">Q=14</td><td style="text-align:center">-131072≤x≤131071.999 938 965</td><td style="text-align:center">2^(-14)</td></tr><tr><td style="text-align:center">Q=13</td><td style="text-align:center">-262144≤x≤262143.999 877 930</td><td style="text-align:center">2^(-13)</td></tr><tr><td style="text-align:center">Q=12</td><td style="text-align:center">-5244288≤x≤524287.999 755 859</td><td style="text-align:center">2^(-12)</td></tr><tr><td style="text-align:center">Q=11</td><td style="text-align:center">-1048576≤x≤1048575.999 511 719</td><td style="text-align:center">2^(-11)</td></tr><tr><td style="text-align:center">Q=10</td><td style="text-align:center">-2097152≤x≤2097151.999 511 719</td><td style="text-align:center">2^(-10)</td></tr><tr><td style="text-align:center">Q=9</td><td style="text-align:center">-4194304≤x≤4194302.998 046 875</td><td style="text-align:center">2^(-9)</td></tr><tr><td style="text-align:center">Q=8</td><td style="text-align:center">-8388608≤x≤8388607.996 093 750</td><td style="text-align:center">2^(-8)</td></tr><tr><td style="text-align:center">Q=7</td><td style="text-align:center">-16777216≤x≤16777215.992 187 500</td><td style="text-align:center">2^(-7)</td></tr><tr><td style="text-align:center">Q=6</td><td style="text-align:center">-33554432≤x≤33554431.984 375 000</td><td style="text-align:center">2^(-6)</td></tr><tr><td style="text-align:center">Q=5</td><td style="text-align:center">-67108864≤x≤67108863.968 750 000</td><td style="text-align:center">2^(-5)</td></tr><tr><td style="text-align:center">Q=4</td><td style="text-align:center">-134217728≤x≤134217727.937 500 000</td><td style="text-align:center">2^(-4)</td></tr><tr><td style="text-align:center">Q=3</td><td style="text-align:center">-268435456≤x≤268435455.875 000 000</td><td style="text-align:center">2^(-3)</td></tr><tr><td style="text-align:center">Q=2</td><td style="text-align:center">-536870912≤x≤536870911.750 000 000</td><td style="text-align:center">2^(-2)</td></tr><tr><td style="text-align:center">Q=1</td><td style="text-align:center">-1073741824≤x≤1073741823.500 000 000</td><td style="text-align:center">2^(-1)</td></tr><tr><td style="text-align:center">Q=0</td><td style="text-align:center">-2147483648≤x≤2147483647</td><td style="text-align:center">2^0</td></tr></tbody></table><h2 id="转换关系"><a href="#转换关系" class="headerlink" title="转换关系"></a>转换关系</h2><p>浮点数(X)转换为定点数(Xq)：<code>Xq=(int)X* 2^Q</code></p><p>定点数(Xq)转换为浮点数(X)：<code>X=(float)Xq*2^(-Q)</code></p><p><strong>Example:</strong></p><p>将浮点数X = 0.5转换为32位Q定标的定点数：</p><ul><li><p><strong>(1)由于-1≤X≤0.999 999 999</strong>，按照上述表格所以我们取Q = 31，</p><p>即定点数：Xq=(int)X<em> 2^Q = (int)(0.5 </em> 2^31) = 1073741842;</p><p>反之知道定点数Xq = 1073741842 反推其浮点数如下</p><p>则X=(float)Xq<em>2^(-Q) = (float)1073741842</em>2^(-31) = 0.5;</p><p>​    按照上述如果我们取Q = 31，如果我们要计算浮点的0.5<em>0.5，则相当于计算定点的1073741842 </em> 1073741842 这个数实在是太大了，只能用long long型装下，而非一个字(int)可以装下。通过观察0.5这个数我们只需要保证表格中的Q值对应的精度比0.5更小即可，如此我们重新选择Q：</p></li><li><p><strong>(2)由于-536870912≤x≤536870911.750 000 000</strong>，按照上述表格我们取Q = 2， 即定点数：Xq=(int)X<em> 2^Q = (int)(0.5 </em> 2^2) = 2; 反之知道定点数Xq = 2 反推其浮点数如下 则X=(float)Xq<em>2^(-2) = (float)2</em>2^(-2) = 0.5; 按照上述如果我们取Q = 2，如果我们要计算浮点的0.5<em>0.5，则相当于计算定点的2 </em> 2，一个char就可以装下了。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
            <tag> 定点数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_obj的探究</title>
      <link href="/2018/03/19/lv_obj%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/19/lv_obj%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-obj的作用"><a href="#1-lv-obj的作用" class="headerlink" title="1 lv_obj的作用"></a>1 lv_obj的作用</h1><p>obj 即 对象，也是LittlevGL中构成各种容器、页面、控件最基本的元素，就是说GUI中的各种元素都是在obj的基础上增加扩展功能或修改样式而来的。</p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>使用<code>lv_obj_create</code>创建一个基本的空对象并将其作为屏幕，其父级与样式复制都为NULL<br><img src="http://mypic666.test.upcdn.net/20180504175855.png" alt=""><br>效果：<br><img src="http://mypic666.test.upcdn.net/20180504180154.png" alt=""></p><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_obj.c 中可以看到，如果没有为对象设置父级，则会创建一个新的双向链表，并为双向链表申请内存空间，然后再定义这个对象的在屏幕上的尺寸的大小，同时也会获取当前设置的全局主题。<br><img src="http://mypic666.test.upcdn.net/20180504194605.png" alt=""></p><p>以及对一些属性的初始化设置<br><img src="http://mypic666.test.upcdn.net/20180504200138.png" alt=""></p><p>如果在创建对象的时候设置了父级，则会以父级对象结构体中预设的一个用于子对象创建头结点的指针来创建一个双向链表<br><img src="http://mypic666.test.upcdn.net/20180504200313.png" alt=""></p><p>如果样式复制的参数不为空的话，则会直接将被复制的对象的参数直接赋值给新建的这个对象<br><img src="http://mypic666.test.upcdn.net/20180504204922.png" alt=""></p><p>如果要删除一个对象，可以使用<code>lv_obj_del</code>函数，删除过程是通过以下代码实现的，可以看到对象的数据被标记为无效，然后再删除了其链表中的内容<br><img src="http://mypic666.test.upcdn.net/20180504210509.png" alt=""></p><p>标记对象数据为无效的过程如下，标为无效后在下一次刷新时，此对象的将被刷新掉<br><img src="http://mypic666.test.upcdn.net/20180504212037.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，对象创建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_mem的探究</title>
      <link href="/2018/03/19/lv_mem%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/19/lv_mem%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-mem-的作用"><a href="#1-lv-mem-的作用" class="headerlink" title="1 lv_mem 的作用"></a>1 lv_mem 的作用</h1><p>在 lv_conf 中可以看到LittlevGL的内存管理有两种方式，一种是使用 stdlib 标准库中的<code>malloc</code>和<code>free</code>，另外一种是使用LvGL内建的<code>lv_mem_alloc</code>和<code>lv_mem_free</code>。同时在<code>LV_MEM_SIZE</code>处定义使用的内存大小，如下所示定义为 128KB<br><img src="http://mypic666.test.upcdn.net/20180511204753.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>lv_mem 会根据定义的内存大小初始化一段内存空间，LittlevGL 中所有的数据将在这段内存空间上存储活动。</p><ul><li>如果事先没合理的考虑GUI使用内存的问题，在使用过程中很可能会出现内存溢出的问题，导致在使用GUI中的某个控件或者切换页面时出现崩溃的现象</li><li>一般如果定义的内存大小合理超过GUI正常使用所需要的内存需求时，一般都不会有问题。</li></ul><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_mem 中首先建立一个内存头部信息的结构体，再将这个内存头部信息与申请的内存中的第一个字节的数据作为一个内存记录的结构体，如下所示：<br><img src="http://mypic666.test.upcdn.net/20180511213105.png" alt=""></p><p>定义工作内存空间，即按照在 lv_conf 中定义的大小<br><img src="http://mypic666.test.upcdn.net/20180511214746.png" alt=""></p><p>再初始化内存空间<br><img src="http://mypic666.test.upcdn.net/20180511215011.png" alt=""></p><p>下面是申请内存空间的函数，先判断申请的内存空间是否为4的倍数，不是的话，调整为大于申请的大小的4的倍数的空间。再用这个空间大小去调用<code>ent_alloc()</code>这个函数去进一步申请内存<br><img src="http://mypic666.test.upcdn.net/20180511215946.png" alt=""></p><p>下面是<code>ent_alloc()</code>函数，在传入内存记录和申请大小的参数后，先判断这个内存记录有没有被使用过，再判断记录的空间是否大于申请的空间，如果都满足条件的话会进一步调用<code>ent_trunc()</code>去申请内存，同时将这条内存记录标记为<code>1</code>即被使用了。</p><p><img src="http://mypic666.test.upcdn.net/20180511220940.png" alt=""></p><p>在下面这个函数中，再次进行了申请空间是否为4字节对齐的检查，然后判断申请的空间加上内存头信息的大小是否正好等于内存记录剩余空间的大小，是的话就申请空间为剩余空间大小。之后再判断如果剩余空间与申请的空间不相等的话（这个是建立在内存足够的情况下，也就是不相等的意思就是代表申请空间小于剩余空间，如果大于的情况就是直接溢出程序崩溃，）就新建一个内存记录用于下一次内存申请。<br><img src="http://mypic666.test.upcdn.net/20180511221849.png" alt=""></p><p>下面是内存释放的函数，先判断要释放的数据是否为空，不为空的话然后将这个数据的内存头信息标记为0即未使用，然后进行碎片整理。<br><img src="http://mypic666.test.upcdn.net/20180511224833.png" alt=""></p><p>下面还有个内存碎片整理的函数，但是LittlevGL中默认没有使用到<br><img src="http://mypic666.test.upcdn.net/20180511225546.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_style的探究</title>
      <link href="/2018/03/09/lv_style%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/09/lv_style%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-style的作用"><a href="#1-lv-style的作用" class="headerlink" title="1 lv_style的作用"></a>1 lv_style的作用</h1><p>lv_style的作用是用来为对象设置样式风格。</p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>如下图，比如下面的拖动条，是在设置了主题样式之后才有的这种视觉效果，其实LittlevGL默认就有一套固定的主题样式，如果你不设置主题样式，就会使用默认的主题样式，只是比较丑而已，也就是说，有了主题样式之后你才能看到这个对象的外观形态，否则是看不到的。<br><img src="http://mypic666.test.upcdn.net/20180507205941.png" alt=""><br><a id="more"></a></p><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在文件的开头设置了13个默认风格的样式<br><img src="http://mypic666.test.upcdn.net/20180507211158.png" alt=""></p><p>在初始化风格样式的时候，首先以 <code>lv_style_scr</code> 制定了第一种样式，也就是最基本的<br><img src="http://mypic666.test.upcdn.net/20180507211427.png" alt=""></p><p>而对于 <code>lv_style_plain</code> ，则是照搬 <code>lv_style_scr</code> 的设置，所以 <code>lv_style_plain</code> 与 <code>lv_style_scr</code> 可以说是一模一样的。<br><img src="http://mypic666.test.upcdn.net/20180507211700.png" alt=""></p><p>后面的做法也是一样，都是以 <code>lv_style_plain</code> 为基本模板，在此基础上修改风格样式。<br><img src="http://mypic666.test.upcdn.net/20180507211918.png" alt=""></p><p>再如透明的风格，就是将对象的“身体”设置为空，以及一些边框的宽度设置为0，使其看上去有透明的感觉<br><img src="http://mypic666.test.upcdn.net/20180507212237.png" alt=""></p><p>最后就是按钮的风格，“释放” 与 “按下” 两种风格，“释放”风格根据基本的模板风格来修改，而“按下”则根据“释放”的来修改<br><img src="http://mypic666.test.upcdn.net/20180507212623.png" alt=""></p><p>如果你想自定义自己喜欢的风格，可以以这13个样式风格为最基本的风格，自己新建一个样式风格的同时将基本的样式风格copy过来，再在新建的风格上进行修改。如下接口便提供这个功能，第一个参数是你新建的样式风格的名称，第二个参数是任意一个已存在的样式风格。<br><img src="http://mypic666.test.upcdn.net/20180507213018.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，风格样式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_vdb的探究</title>
      <link href="/2018/03/02/lv_vdb%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/02/lv_vdb%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-vdb-的作用"><a href="#1-lv-vdb-的作用" class="headerlink" title="1 lv_vdb 的作用"></a>1 lv_vdb 的作用</h1><p>在 lv_conf 中，可以看到 <code>LV_VDB_SIZ</code> 是用来设置屏幕虚拟缓存的<br><img src="http://mypic666.test.upcdn.net/20180508205758.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>如果将 <code>LV_VDB_SIZ</code>的值设为0，在编译的时候就会提示必须关闭LIttlevGL 内置的抗锯齿功能。</p><ul><li>将屏幕虚拟缓存值设为0时，模拟器界面打开后出现闪烁的情况，并且界面上的图片无法显示，带Alpha通道的图标会显示不正常，锯齿变得很明显，而且动画效果也会消失。</li><li>在屏幕虚拟缓存值为默认值时各项功能都正常。</li></ul><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>需要注意的是，lv_conf 提供了屏幕虚拟双缓缓存的选项，这个也是为了加快刷新速度，再在上一帧开始刷新的同时就预先把下一帧的图像缓存起来，也就是不需要等待缓存过程而是直接用缓存的数据刷新。由于单缓缓存就已经满足我们的需求所以没必要去设置双缓存了。</p><p>lv_vdb 文件比较简单，首先是确定是否开启了双缓存，再看是否使用了DMA，然后直接根据 lv_conf 中设置的缓存大小来建立缓存区<br><img src="http://mypic666.test.upcdn.net/20180508220815.png" alt=""></p><p>再就是获取缓存区指针的函数<br><img src="http://mypic666.test.upcdn.net/20180508224151.png" alt=""></p><p>刷新屏幕时先获取缓存区的地址，再将缓存区内的数据刷上屏幕<br><img src="http://mypic666.test.upcdn.net/20180508222223.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，虚拟缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win下LittlevGL模拟器环境的搭建</title>
      <link href="/2018/01/29/win%E4%B8%8BLittlevGL%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/01/29/win%E4%B8%8BLittlevGL%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h1><p>由于LittleVgl官方提供的Windows下的模拟环境为Eclipse工程，且模拟环境依赖SDL库运行</p><p>所以需要安装以下工具：</p><ul><li><p>MinGW</p></li><li><p>JDK</p></li><li><p>Eclipse CDT</p></li><li><p>SDL2</p></li></ul><h2 id="1-1-安装MinGW"><a href="#1-1-安装MinGW" class="headerlink" title="1.1 安装MinGW"></a>1.1 安装MinGW</h2><p>MinGW, 全称Minimalist GNU for Windows, 是GCC编译器和GNU Binutils在Windows平台的移植版本. MinGW-w64原是其分支, 后来成为独立发展的项目. 由于仅有MinGW-w64被GCC官方所支持, 而MinGW早已停止更新, 因此推荐使用MinGW-w64.</p><a id="more"></a><p><a href="https://sourceforge.net/projects/mingw-w64/files/latest/download" target="_blank" rel="noopener">MinGW-w64下载地址</a></p><ul><li><p>第一步.下载完成后打开安装程序点击下一步选择版本,并选择如下配置</p><p><img src="http://mypic666.test.upcdn.net/mg.png" alt=""></p></li></ul><ul><li><p>第二步.选择路径，记住你选的路径</p><p><img src="http://mypic666.test.upcdn.net/mg1.png" alt=""></p></li></ul><ul><li><p>第三步.安装完成后</p><p>点击 我的电脑&gt;右键属性进行下图设置</p><p><img src="http://mypic666.test.upcdn.net/341522-20180115192027256-1156620245.png" alt=""></p></li><li><p>最主要的是在系统变量的 Path 中加入  “你的路径\mingw64\bin”</p></li><li><p>完成配置之后打开CMD终端 输入 <code>gcc -v</code>,如下图显示即配置成功</p><p><img src="http://mypic666.test.upcdn.net/mgc.png" alt=""></p></li></ul><h2 id="1-2-安装JRE"><a href="#1-2-安装JRE" class="headerlink" title="1.2 安装JRE"></a>1.2 安装JRE</h2><p>因为安装Eclipse CDT需要Java运行环境所以需要安装JRE，建议下载JDK安装包，JDK安装包可以自动配置环境变量，JRE包需要手动配置，且JDK安装包内包含了JRE</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK下载地址</a></p><p><img src="http://mypic666.test.upcdn.net/jdk.png" alt=""></p><ul><li>选择你系统对应的版本下载</li><li>安装包下载完成后直接全部点击下一步直到安装完成即可</li></ul><h2 id="1-3-安装Eclipse-CDT"><a href="#1-3-安装Eclipse-CDT" class="headerlink" title="1.3 安装Eclipse CDT"></a>1.3 安装Eclipse CDT</h2><p><a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse inst下载地址</a></p><ul><li><p>下载完成后直接运行安装包</p></li><li><p>选择如图中的CDT套件</p><p><img src="http://mypic666.test.upcdn.net/cdt.png" alt=""></p></li><li><p>选择之后选择你的安装路径，随后等待安装完成即可使用</p></li></ul><h2 id="1-4-安装SDL2环境"><a href="#1-4-安装SDL2环境" class="headerlink" title="1.4 安装SDL2环境"></a>1.4 安装SDL2环境</h2><p>因为模拟运行LittleVgl需要图形化模拟运行库，所以需要下载SDL2</p><p><a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL2下载地址</a></p><ul><li><p>选择下图中的MinGW版本</p><p><img src="http://mypic666.test.upcdn.net/sdl2.png" alt=""></p></li><li><p>下载完成并解压后进入 x86_64-w64-mingw32  (对应MinGW64位版本) </p></li><li><p>复制 <em>…/SDL2-2.0.7/x86_64-w64-mingw32/include/SDL2</em> <strong>文件夹</strong> 到编译器的文件夹下的如下路径<em>…mingw64/x86_64-w64-mingw32/include</em></p></li><li><p>复制 <em>…/SDL2-2.0.7/x86_64-w64-mingw32/lib/</em> <strong>文件夹下所有内容</strong>到编译器的文件夹下的如下路径 <em>…mingw64/x86_64-w64-mingw32/lib</em></p></li></ul><p>至此环境已经配置完成。</p><h1 id="2-导入LittleVgl工程"><a href="#2-导入LittleVgl工程" class="headerlink" title="2. 导入LittleVgl工程"></a>2. 导入LittleVgl工程</h1><p>首先Git LittleVgl的工程包</p><p>git地址：<a href="https://github.com/littlevgl/pc_simulator.git" target="_blank" rel="noopener">https://github.com/littlevgl/pc_simulator.git</a></p><ul><li><p>启动Eclipse CDT 并设置工作路径</p><p><img src="http://mypic666.test.upcdn.net/eclp.png" alt=""></p></li><li><p>将Git到的pc_simulator文件夹复制到上面设置的工作路径中</p></li><li><p>打开Eclipse CDT 后选择 【文件】&gt;【导入】</p><p>并选择【常规】&gt;【现有项目到工作空间】</p><p><img src="http://mypic666.test.upcdn.net/gzkj.png" alt=""></p><p>​</p></li><li><p>再将根目录定位到 pc_simulator 文件夹,点击完成后即可导入</p><p><img src="http://mypic666.test.upcdn.net/sz.png" alt=""></p></li></ul><h1 id="3-配置项目文件"><a href="#3-配置项目文件" class="headerlink" title="3. 配置项目文件"></a>3. 配置项目文件</h1><p>  ​</p><ul><li><p>pc_simulator项目上（如下图）, 【右键】&gt;【属性】</p><p><img src="http://mypic666.test.upcdn.net/1111.png" alt=""></p></li><li><p>打开之后可以看到下图，在下图中点击【添加】，输入 mingw32，并点击【上移】到最上面一个，最后点击应用。</p><p><img src="http://mypic666.test.upcdn.net/mingw.png" alt=""></p><p>​</p></li><li><p>再打开如下图选项，选择 MinGW GCC 工具，并点击 【应用】。</p><p><img src="http://mypic666.test.upcdn.net/gjj.png" alt=""></p></li><li><p>再点击【apply and close】关闭</p></li><li><p>将之前下载的SDL2文件夹中的 ..\x86_64-w64-mingw32\bin\SDL2.dll 文件 复制到 你项目中的 ..\pc_simulator\Debug 文件夹下</p></li><li><p>在Eclipse CDT中 按 <code>Ctrl + B</code>  进行编译</p></li><li><p>点击工具栏中的 <strong>运行配置</strong> 选项，如下图</p><p><img src="http://mypic666.test.upcdn.net/gjl.png" alt=""></p></li><li><p>打开下图运行配置窗口,将 C/C++ 程序定位到项目中的Debug文件夹中生成的.exe文件</p><p><img src="http://mypic666.test.upcdn.net/xxx.png" alt=""></p></li><li><p>然后点击窗口右下角运行后即可显示模拟效果</p><p><img src="http://mypic666.test.upcdn.net/sim.png" alt=""></p></li></ul>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 模拟器 </tag>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Slab</title>
      <link href="/2017/05/18/Slab/"/>
      <url>/2017/05/18/Slab/</url>
      <content type="html"><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>传统的内存分配算法有两种，固定块大小分配法和块相连分配法：</p><ul><li>固定块大小分配法（如ucos ii的内存管理）：分配速度快，算法实现简单，但由于只支持固定的一种或几种的固定块大小，使得内存空间利用率低，不够灵活，不适用于相对复杂的应用。</li><li>块相连分配法：通过指针链表的形式能够实现比较灵活的不同内存大小的分配，但经常需要遍历整个链表，导致耗时长，且容易产生碎片。</li></ul><p><strong>而RT-Thread的slab内存分配算法是上述两种算法的折中，其分两层：</strong></p><ul><li><strong>底层是页分配器</strong></li><li><strong>上层是slab分配器</strong></li></ul><p>其页分配器的本质其实一个以page为单位块相连的分配算法，而其slab分配器则相当个支持72种大小的固定块分配法，所以RT-Thread的slab内存分配算法很好的兼顾了内存分配时的快速性、灵活性、不易产生碎片等要求。而其底层是已page为单位的分配，所以特别适合带虚拟内存交换机制的系统。</p><a id="more"></a><h1 id="slab内存分配"><a href="#slab内存分配" class="headerlink" title="slab内存分配"></a>slab内存分配</h1><h2 id="底层的页分配器算法"><a href="#底层的页分配器算法" class="headerlink" title="底层的页分配器算法"></a>底层的页分配器算法</h2><p>涉及到的函数、变量、数据结构有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_page_alloc</span><span class="params">(<span class="keyword">rt_size_t</span> npages)</span>   <span class="comment">//分配页</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_free</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span> <span class="comment">//释放页</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_init</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">rt_size_t</span> npages)</span> <span class="comment">//页分配器初始化</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span>* end_addr)</span>  <span class="comment">//内存管理初始化</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct rt_page_head <span class="comment">//链表数据结构，正是通过这个数据结构将搜索的页形成一个链表</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(structrt_page_head*) + <span class="keyword">sizeof</span> (<span class="keyword">rt_size_t</span>))];</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">rt_page_list</span>;</span>  <span class="comment">//指向首个可用于分配的页</span></span><br></pre></td></tr></table></figure><p>我们先从rt_system_heap_init入手，可以看到调用rt_page_init对页分配器进行了初始化。</p><ul><li>下图可以看到，在每个连续的空间页的首地址收存放着一个数据结构struct rt_page_head，其元素page代表接下来有多少个连续的空间页可用于分配，next指向下一个与其不连续的空闲页。而全局的链表指针rt_page_list则指向首个可用于分配的空闲页。</li><li>下图还可以看到，RT-Thread的页分配器和常见的块相连分配法的原理一样，但它又有自己的特：<ul><li>它是已页为单位的分配。</li><li>分配之后不需要花空间去记录这次分配的大小，因为上层的slab分配器使用页分配器时都是分配zone_size/4（zone_size一般为128K）大小个的页。</li><li>已分配的页的起始地址的数据内存管理程序已不再使用，完全可以交给申请者使用。</li></ul></li></ul><p><img src="http://img.ph.126.net/Li5oc8TmIrNWxODv4c5Dgg==/626281823198544047.jpg" alt=""></p><h2 id="上层的slab分配器"><a href="#上层的slab分配器" class="headerlink" title="上层的slab分配器"></a>上层的slab分配器</h2><p>首先来解释两个概念，<strong>一个是zone、另一个是chunk</strong></p><ul><li>Chunk：chunk是指一段固定大小的空间，slab分配器中共支持72种大小的chunk，那72种大小分别是8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128、144、160、176、192、208、224、240、256、288、320、352、384、416、448、480、512、576、640、704、770、834、898、962、1024、1152、1280、1408、1536、1664、1792、1920、2048、2304、2560、2816、3072、3328、3584、3840、4096、4608、5120、5632、6144、6656、7168、7680、8192、9216、10240、11264、12288、13312、14336、15360、16384（具体规律可参考zoneindex函数）。也就是说slab内存分配器只能分配上述大小的空间，如果过需要分配的空间不等上述大小，则会通过zoneindex函数自动寻找一个最接近的大小来代替，如果要分配的空间大于16K则，则直接分配一个4K大小对齐的空间。</li><li>Zone：每个zone一般都是128K，每个zone里包含着n个大小相同的chunk，所以就有72种类型的zone。如某个zone为128K，chunk属于512字节的类型，则说明它包含着128*1024/512个chunk。</li></ul><p>接下来说一些主要的数据结构和全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_magic;    <span class="comment">//没什么主要用途，可以不分析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_nfree;    <span class="comment">//该zone里有多少个可用于分配的chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_nmax;     <span class="comment">//该zone里拥有多少个chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>  <span class="comment">//指向下一个同样类型的zone，并且所指向的zone中的chunk没有分配完，否则为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *z_baseptr;     <span class="comment">//该zone第一个chunk的偏移，因为zone起始地址存放着这个数据结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_uindex;       <span class="comment">//每次分配chunk就自加1，直到z_uindex+1= z_nmax,就会从z_freechunk中寻找可分配的chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_chunksize;   <span class="comment">//该zone中每个chunk的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_zoneindex;   <span class="comment">//对应的zoneindex，其实就是跟chunk的大小有关，大小为8时index为0，大小为16384时index为71</span></span><br><span class="line"></span><br><span class="line">    slab_chunk *z_freechunk; <span class="comment">//指向该zone中首个已被free掉的chunk，如果没有则为NULL</span></span><br><span class="line"></span><br><span class="line">&#125; slab_zone;</span><br></pre></td></tr></table></figure><p>该数据结构存放在没有zone的起始空间中，描述了该zone的类型，该zone里面有哪些chunk可用于分配，哪些chunk被free了，下一个同类型的zone的地址等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_uint32_t</span> type:<span class="number">2</span> ;                   <span class="comment">//记录着对应空间分配的chunk是小于等于16K类型的还是大于16K的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_uint32_t</span> size:<span class="number">30</span>;    <span class="comment">//如果是大于16K的类型，则记录具体分配的大小，否则记录该页在zone中的编号（因为每个zone包含32个页，也就是记录页号）</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个堆空间有多少个页就会开辟多少个这样的数据结构记录着对应页的状态。</p><p><code>zone_array[NZONES]</code></p><p>有72种类型的zone，所以就有上述的72的指针数组，分别指向对应类型的zone的首地址，然后这个zone数据结构又会指向下一个同类型的zone，所以全部同类型的zone就组成了一个链表。</p><p>接下来说说一下大概分配内存的过程：</p><ul><li>首先初始化的时候zone_array[NZONES]会被全部置空，表明没有任何可用的zone，然后调用rt_malloc（200）申请200字节的空间，通过zoneindex函数后调整申请大小为208，且zoneindex为20，然后查询zone_array[20]发现为空，则说明208字节chunk大小类型的zone没有被建立或者没有一个包含空闲chunk的这样类型的zone。</li><li>然后就会建立一个新的且chunk大小为208字节的zone，通过rt_page_alloc 32个page实现，因为每个zone都为32*4K大小。</li><li>然后在所申请的页对应的memusage数组设置相应的标志及编号，然后初始化slab_zone数据结构，然后返回该zone内第一个chunk的地址，申请成功。</li></ul><p><img src="http://mypic666.test.upcdn.net/626281823198544048.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/626281823198544049.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/1009650741478466271.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/1009650741478466272.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/626281823198544050.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> slab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机字符编码</title>
      <link href="/2016/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2016/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h1><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节”。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”</p><p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><a id="more"></a> <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>字符(Character)</strong> 是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</li><li><strong>字符集(Character set)</strong> 是一个系统支持的所有抽象字符的集合。通常以二维表的形式存在，二维表的内容和大小是由使用者的语言而定。如ASCII,GBxxx,Unicode等。</li><li><strong>字符编码(Character encoding)</strong> 是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。每个字符集中的字符都对应一个唯一的二进制编码。</li></ul><h1 id="常见字符集及编码"><a href="#常见字符集及编码" class="headerlink" title="常见字符集及编码"></a>常见字符集及编码</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII(American Standard Code for Information Interchange, 美国信息交换标准代码)</strong>是基于拉丁字母的一套电脑编码系统，使用7个或8个二进制位进行编码的方案，最多可以给256个字符 (包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值。 它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准<strong>ISO/IEC 646</strong>。</p><p>ASCII码于1961年提出，用于在不同计算机硬件和软件系统中实现数据传输标准化，在大多数的小型机和全部的个人计算机都使用此码。ASCII码划分为两个集合：128个字符的标准ASCII码和附加的128个字符的扩充和ASCII码。</p><p> 目前使用最广泛的西文字符集及其编码是 ASCII 字符集和 ASCII 码（ ASCII 是 American Standard Code for Information Interchange 的缩写），它同时也被国际标准化组织（ International Organization for Standardization, ISO ）批准为国际标准。</p><p> 基本的 ASCII 字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。标准 ASCII 码使用 7 个二进位对字符进行编码，对应的 ISO 标准为 ISO646 标准。下表展示了基本 ASCII 字符集及其编码：</p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=c05506e79482d158af8f51e3e16372bd/c2fdfc039245d688c56332adacc27d1ed21b2451.jpg" alt=""></p><p>Unicode,GBXXX,UTF-8等字符编码都兼容ASCII编码。</p><p><strong>EASCII</strong>(Extended ASCII，延伸美国标准信息交换码)是将ASCII码由7位扩充为8位而成。EASCII的内码是由0到255共有256个字符组成。EASCII码比ASCII码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。</p><h2 id="MBCS"><a href="#MBCS" class="headerlink" title="MBCS"></a>MBCS</h2><p>为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI 编码即可。 不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。一个很大的缺点是，同一个编码值，在不同的编码体系里代表着不同的字。这样就容易造成混乱。</p><p>导致了unicode码的诞生。 其中每个语言下的ANSI编码，都有一套一对一的编码转换器，Unicode变成所有编码转换的中间介质。所有的编码都有一个转换器可以转换到Unicode，而Unicode也可以转换到其他所有的编码。</p><h2 id="GB2312字符集-amp-编码"><a href="#GB2312字符集-amp-编码" class="headerlink" title="GB2312字符集&amp;编码"></a>GB2312字符集&amp;编码</h2><p><strong>GB 2312</strong> 或称 <strong>GB 2312–80</strong> 是中华人民共和国国家标准简体中文字符集，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<strong>GB0</strong>，由中国国家标准总局发布，1981年5月1日实施。GB 2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p><p><strong>字符集范围</strong></p><p>GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><p>GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312不能处理，因此后来GBK及GB 18030汉字字符集相继出现以解决这些问题。</p><p> <strong>分区</strong></p><p>GB 2312中对所收汉字进行了“分区”处理，每区含有94个汉字／符号。这种表示方式也称为区位码。</p><table><thead><tr><th>分区范围</th><th>符号类型</th></tr></thead><tbody><tr><td>第01区</td><td>中文标点、数学符号以及一些特殊字符</td></tr><tr><td>第02区</td><td>各种各样的数学序号</td></tr><tr><td>第03区</td><td>全角西文字符</td></tr><tr><td>第04区</td><td>日文平假名</td></tr><tr><td>第05区</td><td>日文片假名</td></tr><tr><td>第06区</td><td>希腊字母表</td></tr><tr><td>第07区</td><td>俄文字母表</td></tr><tr><td>第08区</td><td>中文拼音字母表</td></tr><tr><td>第09区</td><td>制表符号</td></tr><tr><td>第10－15区</td><td>无字符</td></tr><tr><td>第16－55区</td><td>一级汉字（以拼音字母排序）</td></tr><tr><td>第56－87区</td><td>二级汉字（以部首笔画排序）</td></tr><tr><td>第88－94区</td><td>无字符</td></tr></tbody></table><p>举例来说，“啊”字是GB 2312之中的第一个汉字，它的区位码就是1601。<br>10–15区及88–94区则未有编码。</p><p><strong>编码格式</strong></p><p>在使用GB 2312的程序通常采用<a href="https://zh.wikipedia.org/wiki/EUC" target="_blank" rel="noopener">EUC</a>储存方法，以便兼容于ASCII。<br>每个汉字及符号以两个字节来表示。第一个字节称为“高位字节”，第二个字节称为“低位字节”。<br>“高位字节”使用了<code>0xA1–0xF7</code>（把01–87区的区号加上0xA0），“低位字节”使用了<code>0xA1–0xFE</code>（把01–94加上0xA0）。 由于一级汉字从16区起始，汉字区的“高位字节”的范围是0xB0–0xF7，“低位字节”的范围是0xA1–0xFE，占用的码位是72*94=6768。其中有5个空位是D7FA–D7FE。</p><h2 id="GBK字符集-amp-编码"><a href="#GBK字符集-amp-编码" class="headerlink" title="GBK字符集&amp;编码"></a>GBK字符集&amp;编码</h2><p><strong>汉字内码扩展规范</strong>，称<strong>GBK</strong>，全名为<strong>《汉字内码扩展规范(GBK)》1.0版</strong>，由中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订，国家技术监督局标准化司和电子工业部科技与质量监督司1995年12月15日联合以《技术标函[1995]229号》文件的形式公布。</p><p>GBK的<strong>K</strong>为汉语拼音Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Extension Specification。</p><p>GB 2312-80只收录6763个汉字，有不少汉字，如部分在GB 2312-80推出以后才简化的汉字（如“啰”），部分人名用字（如中国前总理朱镕基的“镕”字），台湾及香港使用的繁体字，日语及朝鲜语汉字等，并未有收录在内。GBK对GB 2312-80进行扩展, 总计拥有 23940 个码位，共收入21886个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号883 个。</p><p><strong>计算公式</strong></p><p>GBK码对字库中偏移量的计算公式为：</p><p>[(GBKH-0x81)<em>0xBE+(GBKL-0x41)]</em>(汉字离散后每个汉字点阵所占用的字节)</p><p><strong>编码格式</strong></p><p>GBK有一<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>和双字节编码，00–7F范围内是一位，和<a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a>保持一致，此范围内严格上说有96个字符和32个控制符号。</p><p>之后的双<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>中，前一字节是双字节的第一位。总体上说第一<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>的范围是81–FE（也就是不含80和FF），第二字节的一部分领域在40–7E，其他领域在80–FE。</p><p><img src="pic cache/gbk.png" alt=""></p><p>GBK向下完全兼容GB2312-80编码。支持GB2312-80编码不支持的部分中文姓，中文繁体，日文假名，还包括希腊字母以及俄语字母等字母。不过这种编码不支持韩国字，也是其在实际使用中与unicode编码相比欠缺的部分。</p><h2 id="GB-18030字符集-amp-编码"><a href="#GB-18030字符集-amp-编码" class="headerlink" title="GB 18030字符集&amp;编码"></a>GB 18030字符集&amp;编码</h2><p><strong>GB 18030</strong>，全称：国家标准GB 18030-2005《信息技术　中文编码字符集》，是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术　信息交换用汉字编码字符集　基本集的扩充》的修订版。与GB 2312-1980完全兼容，与GBK基本兼容；支持GB 13000（93版等同于Unicode 1.1；2010版等同于Unicode 4.0）及Unicode的全部统一汉字，共收录汉字70,244个。</p><p>本规格的初版是由中华人民共和国信息产业部电子工业标准化研究所起草，由国家质量技术监督局于2000年3月17日发布。现行版本为国家质量监督检验总局和中国国家标准化管理委员会于2005年11月8日发布，2006年5月1日实施。</p><p>此标准内的单字节编码部分、双字节编码部分，和四字节编码部分收录的中日韩统一表意文字扩展A区汉字，为强制性标准。其他部分则属于规模性标准。在中华人民共和国境内所有软件产品，都需要支持这个同时包含单字节、双字节和四字节编码的规格。</p><p>GB 18030主要有以下特点：</p><ul><li>和UTF-8一样都采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字元。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字。</li></ul><p><strong>编码方式</strong></p><ul><li>单字节，其值从0x00到0x7F。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F）。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><h2 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h2><p>在台湾、香港与澳门地区，使用的是繁体中文字符集。而1980年发布的GB2312面向简体中文字符集，并不支持繁体汉字。在这些使用繁体中文字符集的地区，一度出现过很多不同厂商提出的字符集编码，这些编码彼此互不兼容，造成了信息交流的困难。为统一繁体字符集编码，1984年，台湾五大厂商宏碁、神通、佳佳、零壹以及大众一同制定了一种繁体中文编码方案，因其来源被称为五大码，英文写作Big5，后来按英文翻译回汉字后，普遍被称为大五码。</p><p>大五码是一种繁体中文汉字字符集，其中繁体汉字13053个，808个标点符号、希腊字母及特殊符号。大五码的编码码表直接针对存储而设计，每个字符统一使用两个字节存储表示。第1字节范围81H－FEH，避开了同ASCII码的冲突，第2字节范围是40H－7EH和A1H－FEH。因为Big5的字符编码范围同GB2312字符的存储码范围存在冲突，所以在同一正文不能对两种字符集的字符同时支持。</p><p>Big5编码的分布如表1－5所示，Big5字符主要部分集中在三个段内：标点符号、希腊字母及特殊符号；常用汉字；非常用汉字。其余部分保留给其他厂商支持。</p><p>Big5字符编码分布表</p><table><thead><tr><th>编码范围</th><th>符号类别</th></tr></thead><tbody><tr><td>8140H－A0FEH</td><td>保留（用作造字区）</td></tr><tr><td>A140H－A3BFH</td><td>标点符号、希腊字母及特殊符号</td></tr><tr><td>A3C0H－A3FEH</td><td>保留（未开放用于造字区）</td></tr><tr><td>A440H－C67EH</td><td>常用汉字（先按笔划，再按部首排序）</td></tr><tr><td>C6A1H－C8FEH</td><td>保留（用作造字区）</td></tr><tr><td>C940H－F9D5H</td><td>非常用汉字（先按笔划，再按部首排序）</td></tr><tr><td>F9D6H－FEFEH</td><td>保留（用作造字区）</td></tr></tbody></table><p>Big5编码推出后，得到了繁体中文软件厂商的广泛支持，在使用繁体汉字的地区迅速普及使用。目前，Big5编码在台湾、香港、澳门及其他海外华人中普遍使用，成为了繁体中文编码的事实标准。在互联网中检索繁体中文网站，所打开的网页中，大多都是通过Big5编码产生的文档。</p><h2 id="Unicode字符集-amp-编码"><a href="#Unicode字符集-amp-编码" class="headerlink" title="Unicode字符集&amp;编码"></a>Unicode字符集&amp;编码</h2><p>世界上存在着多种编码方式，在ANSi编码下，同一个编码值，在不同的编码体系里代表着不同的字。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，可能最终显示的是中文，也可能显示的是日文。在ANSI编码体系下，要想打开一个文本文件，不但要知道它的编码方式，还要安装有对应编码表，否则就可能无法读取或出现乱码。为什么电子邮件和网页都经常会出现乱码，就是因为信息的提供者可能是日文的ANSI编码体系和信息的读取者可能是中文的编码体系，他们对同一个二进制编码值进行显示，采用了不同的编码，导致乱码。</p><p>如果有一种编码，将世界上所有的符号都纳入其中，无论是英文、日文、还是中文等，大家都使用这个编码表，就不会出现编码不匹配现象。每个符号对应一个唯一的编码，乱码问题就不存在了。这就是Unicode编码。</p><p><strong>Unicode</strong>（中文：<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>、<strong>单一码</strong>）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。<br>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2016年6月21日公布的9.0.0,已经收入超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p><p>Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案替换既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。</p><p>Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言、Java编程语言以及现代的操作系统，都采用Unicode编码。</p><p><strong>编码方式</strong></p><p>统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示2的16次方（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。</p><p>Unicode原编码占用两个字节,在使用ASCII字符时,高位字节的8位始终为0,这会造成空间的浪费。为了避免这种浪费，Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicode转换格式</strong>（Unicode Transformation Format，简称为UTF）。<br>UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p><h2 id="UTF-8-编码"><a href="#UTF-8-编码" class="headerlink" title="UTF-8 编码"></a>UTF-8 编码</h2><p><strong>UTF-8</strong>（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码，也是一种前缀码。其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。</p><p>UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节）：</p><ul><li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</li><li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</li><li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</li><li>其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。</li></ul><p>对上述提及的第四种字符而言，UTF-8使用四至六个字节来编码似乎太耗费资源了。但UTF-8对所有常用的字符都可以用三个字节表示，而且它的另一种选择，UTF-16编码，对前述的第四种字符同样需要四个字节来编码，所以要决定UTF-8或UTF-16哪种编码比较有效率，还要视所使用的字符的分布范围而定。</p><p><strong>编码方式</strong></p><ul><li>单字节字符的最高有效比特永远为0。</li><li>多字节序列中的首个字符组的几个最高有效比特决定了序列的长度。最高有效位为<code>110</code>的是2字节序列，而<code>1110</code>的是三字节序列，如此类推。</li><li>多字节序列中其余的字节中的首两个最高有效比特为<code>10</code>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1894803-67a4baf55ee972b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
