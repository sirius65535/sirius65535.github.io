<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python3基础知识5</title>
      <link href="/2018/04/29/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/"/>
      <url>/2018/04/29/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/</url>
      <content type="html"><![CDATA[<h1 id="1-循环语句"><a href="#1-循环语句" class="headerlink" title="1 循环语句"></a>1 循环语句</h1><p>Python中的循环语句有for和while<br>同样需要注意冒号和缩进。另外，在Python中没有do..while循环。</p><h1 id="2-while-循环"><a href="#2-while-循环" class="headerlink" title="2 while 循环"></a>2 while 循环</h1><p>比如使用了 while 来计算 1 到 1000 的总和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">n =  1000</span><br><span class="line">sum  =  0</span><br><span class="line">counter =  1</span><br><span class="line">while counter &lt;= n:</span><br><span class="line">sum  =  sum  + counter</span><br><span class="line">counter +=  1</span><br><span class="line">print(&quot;1 到 %d 之和为: %d&quot;  % (n,sum))</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>到 <span class="number">1000</span> 之和为: <span class="number">500500</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="2-1-无线循环"><a href="#2-1-无线循环" class="headerlink" title="2.1 无线循环"></a>2.1 无线循环</h2><p>通过设置条件表达式永远为true来实现无限循环，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">var,cnt=  1,0</span><br><span class="line">num =  int(input(&quot;输入一个数字 :&quot;))</span><br><span class="line"></span><br><span class="line">while var ==  1 : # 表达式永远为 true</span><br><span class="line">print (cnt,&quot;你输入的数字是: &quot;, num)</span><br><span class="line">cnt = cnt+1</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入一个数字  :666</span><br><span class="line">...</span><br><span class="line"><span class="attribute">176736 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176737 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176738 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176739 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176740 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176741 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176742 你输入的数字是</span>:  666</span><br><span class="line"><span class="attribute">176743 你输入的数字是</span>:  666</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p><h2 id="2-2-while-循环使用-else-语句"><a href="#2-2-while-循环使用-else-语句" class="headerlink" title="2.2 while 循环使用 else 语句"></a>2.2 while 循环使用 else 语句</h2><p>在 while … else 在条件语句为 false 时执行 else 的语句块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">count =  0</span><br><span class="line">while count &lt;  5:</span><br><span class="line">print (count, &quot; 小于 5&quot;)</span><br><span class="line">count = count +  1</span><br><span class="line">else:</span><br><span class="line">print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span> 小于 <span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span> 大于或等于 <span class="number">5</span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-简单语句组"><a href="#2-3-简单语句组" class="headerlink" title="2.3 简单语句组"></a>2.3 简单语句组</h2><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">flag =  1</span><br><span class="line">while (flag): print (&apos;无限死循环~&apos;)</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">无限死循环~</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="2-4-for语句"><a href="#2-4-for语句" class="headerlink" title="2.4 for语句"></a>2.4 for语句</h2><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">sites =  [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Amazon&quot;,&quot;Taobao&quot;]</span><br><span class="line">for site in sites:</span><br><span class="line">if site ==  &quot;Taobao&quot;:</span><br><span class="line">print(&quot;马云爸爸!&quot;)</span><br><span class="line">break</span><br><span class="line">print(&quot;循环数据 &quot;  + site)</span><br><span class="line">else:</span><br><span class="line">print(&quot;没有循环数据!&quot;)</span><br><span class="line">print(&quot;完成循环!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">循环数据 Baidu</span><br><span class="line">循环数据 Google</span><br><span class="line">循环数据 Amazon</span><br><span class="line">马云爸爸!</span><br><span class="line">完成循环!</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="2-5-range-函数"><a href="#2-5-range-函数" class="headerlink" title="2.5 range() 函数"></a>2.5 range() 函数</h2><p>如果你需要遍历数字序列，可以使用内置range()函数，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for i in  range(5):</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(5,9) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(0, 10, 3) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">for i in  range(-10, -100, -30) :</span><br><span class="line">print(i)</span><br><span class="line">print(&apos;\n------------------------------\n&apos;)</span><br><span class="line">sites =  [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Amazon&quot;,&quot;Taobao&quot;]</span><br><span class="line">for sites in  range(len(a)):</span><br><span class="line">print(i, a[i])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">0 Baidu</span><br><span class="line">1 Google</span><br><span class="line">2 Amazon</span><br><span class="line">3 Taobao</span><br></pre></td></tr></table></figure></p><h2 id="2-6-break和continue语句及循环中的else子句"><a href="#2-6-break和continue语句及循环中的else子句" class="headerlink" title="2.6 break和continue语句及循环中的else子句"></a>2.6 break和continue语句及循环中的else子句</h2><p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for letter in  &apos;orange&apos;: # 第一个实例</span><br><span class="line">if letter ==  &apos;n&apos;:</span><br><span class="line">break</span><br><span class="line">print (&apos;当前字母为 :&apos;, letter)</span><br><span class="line"></span><br><span class="line">var =  10  # 第二个实例</span><br><span class="line">while var &gt;  0:</span><br><span class="line">print (&apos;当期变量值为 :&apos;, var)</span><br><span class="line">var = var -1</span><br><span class="line">if var ==  5:</span><br><span class="line">break</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前字母为 : <span class="type">r</span></span><br><span class="line">当前字母为 : <span class="type">a</span></span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">for letter in  &apos;orange&apos;: # 第一个实例</span><br><span class="line">if letter ==  &apos;n&apos;:</span><br><span class="line">continue</span><br><span class="line">print (&apos;当前字母为 :&apos;, letter)</span><br><span class="line">var =  10  # 第二个实例</span><br><span class="line">while var &gt;  0:</span><br><span class="line">print (&apos;当期变量值为 :&apos;, var)</span><br><span class="line">var = var -1</span><br><span class="line">if var ==  5:</span><br><span class="line">continue</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当前字母为 : <span class="type">o</span></span><br><span class="line">当前字母为 : <span class="type">r</span></span><br><span class="line">当前字母为 : <span class="type">a</span></span><br><span class="line">当前字母为 : <span class="type">g</span></span><br><span class="line">当前字母为 : <span class="type">e</span></span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">当期变量值为 : 5</span><br><span class="line">当期变量值为 : 4</span><br><span class="line">当期变量值为 : 3</span><br><span class="line">当期变量值为 : 2</span><br><span class="line">当期变量值为 : 1</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure></p><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p><h2 id="2-7-pass语句"><a href="#2-7-pass语句" class="headerlink" title="2.7 pass语句"></a>2.7 pass语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。<br>pass 不做任何事情，一般用做占位语句，例如：<br>在 C/C++ 中:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) </span><br><span class="line">; <span class="comment">//do nothing </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在Python中则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if  true: </span><br><span class="line">    pass #do  nothing  </span><br><span class="line">else: </span><br><span class="line">    #do something</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，循环语句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识4</title>
      <link href="/2018/04/27/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864/"/>
      <url>/2018/04/27/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864/</url>
      <content type="html"><![CDATA[<h1 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1 斐波那契数列"></a>1 斐波那契数列</h1><p>在 Python3 中赋值符号两侧可以同时对应的多个变量赋值，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b,c,d =  1,2,3,4</span><br><span class="line">print(&quot;a:&quot;,a)</span><br><span class="line">print(&quot;b:&quot;,b)</span><br><span class="line">print(&quot;c:&quot;,c)</span><br><span class="line">print(&quot;d:&quot;,d)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">a:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">b:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">c:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">d:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>编写斐波那契数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b = 0,1</span><br><span class="line">while b&lt;20:</span><br><span class="line">    print(b)</span><br><span class="line">    a,b = b,a+b</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure></p><p>如果需要在同一行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">a,b = 0,1</span><br><span class="line">while b&lt;20:</span><br><span class="line">    print(b,end=&quot; &quot;)</span><br><span class="line">    a,b = b,a+b</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span></span><br></pre></td></tr></table></figure></p><h1 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2 条件语句"></a>2 条件语句</h1><h2 id="2-1-if语句"><a href="#2-1-if语句" class="headerlink" title="2.1 if语句"></a>2.1 if语句</h2><p>Python中if语句的一般形式如下所示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  co<span class="symbol">ndition_1</span>: </span><br><span class="line">    stateme<span class="symbol">nt_block_1</span>  </span><br><span class="line">elif  co<span class="symbol">ndition_2</span>: </span><br><span class="line">    stateme<span class="symbol">nt_block_2</span>  </span><br><span class="line">else: </span><br><span class="line">    stateme<span class="symbol">nt_block_3</span></span><br></pre></td></tr></table></figure></p><ul><li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li><li>如果 “condition_1” 为False，将判断 “condition_2”</li><li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li><li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li></ul><p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><p><strong>注意：</strong></p><ul><li>1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。</li><li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>3、在Python中没有switch – case语句。</li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">age =  int(input(&quot;请输入你家狗狗的年龄: &quot;))</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">if age &lt; 0  or age == 0:</span><br><span class="line">print(&quot;你是在逗我吧!&quot;)</span><br><span class="line">elif age ==  1:</span><br><span class="line">print(&quot;相当于 14 岁的人。&quot;)</span><br><span class="line">elif age ==  2:</span><br><span class="line">print(&quot;相当于 22 岁的人。&quot;)</span><br><span class="line">elif age &gt;  2:</span><br><span class="line">human =  22  + (age -2)*5</span><br><span class="line">print(&quot;对应人类年龄: &quot;, human)</span><br><span class="line">### 退出提示</span><br><span class="line">input(&quot;点击 enter 键退出&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入你家狗狗的年龄: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">你是在逗我吧!</span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入你家狗狗的年龄: 1</span></span><br><span class="line"></span><br><span class="line">相当于 14 岁的人。</span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入你家狗狗的年龄: 15</span></span><br><span class="line"></span><br><span class="line"><span class="section">对应人类年龄:  87</span></span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td></tr><tr><td><code>==</code></td><td>等于，比较对象是否相等</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table><p>数字的比较运算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">number =  7</span><br><span class="line">guess =  -1</span><br><span class="line">print(&quot;数字猜谜游戏!&quot;)</span><br><span class="line">while guess != number:</span><br><span class="line">guess =  int(input(&quot;请输入你猜的数字：&quot;))</span><br><span class="line">if guess == number:</span><br><span class="line">print(&quot;恭喜，你猜对了！&quot;)</span><br><span class="line">elif guess &lt; number:</span><br><span class="line">print(&quot;猜的数字小了...&quot;)</span><br><span class="line">elif guess &gt; number:</span><br><span class="line">print(&quot;猜的数字大了...&quot;)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数字猜谜游戏!</span><br><span class="line">请输入你猜的数字：<span class="number">1</span></span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：<span class="number">6</span></span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：<span class="number">12</span></span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：<span class="number">8</span></span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：<span class="number">7</span></span><br><span class="line">恭喜，你猜对了！</span><br></pre></td></tr></table></figure></p><h2 id="2-2-if嵌套"><a href="#2-2-if嵌套" class="headerlink" title="2.2 if嵌套"></a>2.2 if嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式1:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式2:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式3:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式4:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">num</span>=int(input("输入一个数字："))</span><br><span class="line"><span class="keyword">if</span> num%<span class="attribute">2</span>==0:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="attribute">3</span>==0:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 2 和 3"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 2，但不能整除 3"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num%<span class="attribute">3</span>==0:</span><br><span class="line">        <span class="builtin-name">print</span> (<span class="string">"你输入的数字可以整除 3，但不能整除 2"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="builtin-name">print</span>  (<span class="string">"你输入的数字不能整除 2 和 3"</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个数字：<span class="number">9</span></span><br><span class="line">你输入的数字可以整除 <span class="number">3</span>，但不能整除 <span class="number">2</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，斐波那契 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识3</title>
      <link href="/2018/04/26/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/"/>
      <url>/2018/04/26/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-字典"><a href="#1-Python3-字典" class="headerlink" title="1 Python3 字典"></a>1 Python3 字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure></p><p>而这一特性与 Json 十分相似，例如某个 Json对象:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">a</span>:<span class="number">666</span>,<span class="attr">b</span>:<span class="string">"Hello"</span>,<span class="attr">c</span>:<span class="string">"World"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>某个Python3字典例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="1-1-访问字典里的值"><a href="#1-1-访问字典里的值" class="headerlink" title="1.1 访问字典里的值"></a>1.1 访问字典里的值</h2><p>访问字典里的值，只需要找到对应的键就可以了，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Mayun&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125; </span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;]) </span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  <span class="symbol">Mayun</span></span><br><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">7</span></span><br></pre></td></tr></table></figure></p><h2 id="1-2-修改字典的值"><a href="#1-2-修改字典的值" class="headerlink" title="1.2 修改字典的值"></a>1.2 修改字典的值</h2><p>向字典添加新内容的方法是增加新的键/值对，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line"></span><br><span class="line">dict[&apos;Age&apos;]  =  22; # 更新 Age</span><br><span class="line">dict[&apos;School&apos;]  =  &quot;ABC&quot;  # 添加信息</span><br><span class="line"></span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Age'</span>]:  <span class="number">22</span></span><br><span class="line">dict[<span class="string">'School'</span>]:  <span class="symbol">ABC</span></span><br></pre></td></tr></table></figure></p><h2 id="1-3-删除字典元素"><a href="#1-3-删除字典元素" class="headerlink" title="1.3 删除字典元素"></a>1.3 删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3  </span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class="line"></span><br><span class="line">del  dict[&apos;Name&apos;]  # 删除键 &apos;Name&apos;</span><br><span class="line">dict.clear()  # 清空字典,字典还存在</span><br><span class="line">del  dict  # 删除字典，字典不存在</span><br><span class="line"></span><br><span class="line">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">189</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print (<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">TypeError: <span class="string">'type'</span> <span class="keyword">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure></p><h2 id="1-4-字典的特性"><a href="#1-4-字典的特性" class="headerlink" title="1.4 字典的特性"></a>1.4 字典的特性</h2><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>两个重要的点需要记住：</p><ul><li><p>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict  = &#123;&apos;Name&apos;: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Name&apos;: &apos;Mike&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure><p>  输出结果：</p>  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[<span class="string">'Name'</span>]:  <span class="symbol">Mike</span></span><br></pre></td></tr></table></figure></li><li><p>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">dict  = &#123;[&apos;Name&apos;]: &apos;Jack&apos;, &apos;Age&apos;: 16, &apos;Name&apos;: &apos;Mike&apos;&#125;</span><br><span class="line">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br></pre></td></tr></table></figure><p>  输出结果：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">183</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Jack'</span>, <span class="string">'Age'</span>: <span class="number">16</span>, <span class="string">'Name'</span>: <span class="string">'Mike'</span>&#125;</span><br><span class="line">TypeError: unhashable <span class="keyword">type</span>: <span class="string">'list'</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5-字典内置函数"><a href="#1-5-字典内置函数" class="headerlink" title="1.5 字典内置函数"></a>1.5 字典内置函数</h2><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1</td><td>radiansdict.clear() 删除字典内所有元素</td></tr><tr><td>2</td><td>radiansdict.copy() 返回一个字典的浅复制</td></tr><tr><td>3</td><td>radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td>4</td><td>radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值</td></tr><tr><td>5</td><td>key in dict 如果键在字典dict里返回true，否则返回false</td></tr><tr><td>6</td><td>radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td>7</td><td>radiansdict.keys() 以列表返回一个字典所有的键</td></tr><tr><td>8</td><td>radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td>9</td><td>radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里</td></tr><tr><td>10</td><td>radiansdict.values() 以列表返回字典中的所有值</td></tr><tr><td>11</td><td>pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td>12</td><td>popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对)。</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_indev的探究</title>
      <link href="/2018/04/23/lv_indev%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/04/23/lv_indev%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-indev的作用"><a href="#1-lv-indev的作用" class="headerlink" title="1 lv_indev的作用"></a>1 lv_indev的作用</h1><p>在LittlevGL的全局设置中可以看到(如下图)，lv_indev的作用是定义获取输入操作的周期，单位为毫秒。<br><img src="http://mypic666.test.upcdn.net/20180427145443.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><ul><li>当<code>#define  LV_INDEV_READ_PERIOD  10</code>的时候，在屏幕上滑动列表，感觉滑动的效果会比较流畅</li><li>当<code>#define  LV_INDEV_READ_PERIOD  50</code>的时候，在屏幕上滑动列表，感觉滑动的效果有明显的卡顿感</li></ul><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_obj.c 文件中可以找到如下定义，lv_indev的启动入口即是从这里开始<br><img src="http://mypic666.test.upcdn.net/20180427161531.png" alt=""></p><a id="more"></a><p>在 lv_indev.c 中可以看到 <code>lv_indev_init()</code>模块的初始化其实是创建了一个任务<br><img src="http://mypic666.test.upcdn.net/20180502180321.png" alt=""></p><p>任务唤醒周期参数<code>LV_INDEV_READ_PERIOD</code> 正好就是全局设置中设置好的宏定义。任务中调用的模块<code>indev_proc_task</code>如下所示<br><img src="http://mypic666.test.upcdn.net/20180502202334.png" alt=""></p><p>可以看到首先是通过<code>indev_proc_task</code>来获取下一个输入操作的指针，<br>如果指针存在，就在载入这个输入操作之前重置其句柄，随后判断如果输入操作没有被禁用，就去读这个输入操作的类型，是长按、点击、组合键盘、还是按钮的类型，并且读取输入操作获取的数据，最后结束判断后再将句柄重置一遍，再获取下一个输入操作的指针，并且标记当前输入活动为空。</p><p>下面是代码是指向下一个输入设备的操作<br><img src="http://mypic666.test.upcdn.net/20180502215426.png" alt=""><br>可以看到，如果没有指定的句柄，就直接返回输入操作的列表，否则就返回句柄中的下一个输入操作。</p><p>而<code>indev_list</code>的值是通过<code>lv_indev_drv_register</code>来获取的的，如下图所示，其实也就是一个带有输入操作参数的结构体，然后其指针被付给了<code>indev_list</code><br><img src="http://mypic666.test.upcdn.net/20180502220704.png" alt=""></p><p>而这个<code>lv_indev_drv_register</code>在 <code>main</code> 函数中被加载<br><img src="http://mypic666.test.upcdn.net/20180502222317.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，设备输入 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识2</title>
      <link href="/2018/04/20/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"/>
      <url>/2018/04/20/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
      <content type="html"><![CDATA[<h1 id="1-Python3-列表"><a href="#1-Python3-列表" class="headerlink" title="1 Python3 列表"></a>1 Python3 列表</h1><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。</p><h2 id="1-1-访问列表中的值"><a href="#1-1-访问列表中的值" class="headerlink" title="1.1 访问列表中的值"></a>1.1 访问列表中的值</h2><p>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  </span><br><span class="line">list1 =  [&apos;Aliyun&apos;, &apos;Baidu&apos;, 1997, 2000];</span><br><span class="line">list2 =  [1, 2, 3, 4, 5, 6, 7  ];</span><br><span class="line">print (&quot;list1[0]: &quot;, list1[0])</span><br><span class="line">print (&quot;list2[1:5]: &quot;, list2[1:5])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1<span class="string">[0]</span>:  Aliyun</span><br><span class="line">list2<span class="string">[1:5]</span>:  <span class="string">[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="1-2-更新列表"><a href="#1-2-更新列表" class="headerlink" title="1.2 更新列表"></a>1.2 更新列表</h2><p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  </span><br><span class="line">list  =  [&apos;Alibaba&apos;, &apos;Baidu&apos;, 2015, 2016]</span><br><span class="line">print (&quot;第二个元素为 : &quot;, list[1])</span><br><span class="line">print (&quot;第三个元素为 : &quot;, list[2])</span><br><span class="line">list[2]  =  2001</span><br><span class="line">print (&quot;更新后的第三个元素为 : &quot;, list[2])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二个元素为 :  <span class="type">Baidu</span></span><br><span class="line">第三个元素为 :  2015</span><br><span class="line">更新后的第三个元素为 :  2001</span><br></pre></td></tr></table></figure></p><h2 id="1-3-删除列表元素"><a href="#1-3-删除列表元素" class="headerlink" title="1.3 删除列表元素"></a>1.3 删除列表元素</h2><p>可以使用 del 语句来删除列表的的元素，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">list  =  [<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2015</span>, <span class="number">2016</span>]</span><br><span class="line"><span class="keyword">print</span> (list)</span><br><span class="line"><span class="keyword">del</span>  list[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"删除第三个元素后 : "</span>, list)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2015</span>, <span class="number">2016</span>]</span><br><span class="line">删除第三个元素后 :  [<span class="string">'Alibaba'</span>, <span class="string">'Baidu'</span>, <span class="number">2016</span>]</span><br></pre></td></tr></table></figure></p><h2 id="1-4-列表脚本操作符"><a href="#1-4-列表脚本操作符" class="headerlink" title="1.4 列表脚本操作符"></a>1.4 列表脚本操作符</h2><p>列表对 <code>+</code>和 <code>*</code> 的操作符与字符串相似。<code>+</code> 号用于组合列表，<code>*</code>号用于重复列表，<code>in</code>判断元素是否存在于列表中，<code>for</code>起迭代作用<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">print(len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  +  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print([<span class="string">'Fuck!'</span>]  *  <span class="number">6</span>)</span><br><span class="line">print(<span class="number">3</span>  <span class="keyword">in</span>  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span>  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]: print(x, end=<span class="string">""</span>)<span class="comment">#end起不换行的作用</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">['Fuck!', 'Fuck!', 'Fuck!', 'Fuck!', 'Fuck!', 'Fuck!']</span><br><span class="line">True</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="1-5-列表截取与拼接"><a href="#1-5-列表截取与拼接" class="headerlink" title="1.5 列表截取与拼接"></a>1.5 列表截取与拼接</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">L=[<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="string">'Samsung'</span>]</span><br><span class="line">print(L[<span class="number">2</span>])</span><br><span class="line">print(L[<span class="number">-2</span>])<span class="comment">#从右侧开始读取倒数第二个元素</span></span><br><span class="line">print(L[<span class="number">-3</span>])</span><br><span class="line">print(L[<span class="number">1</span>:])<span class="comment">#输出从第二个元素开始后的所有元素</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Samsung</span><br><span class="line">Apple</span><br><span class="line">Sony</span><br><span class="line">['Apple', 'Samsung']</span><br></pre></td></tr></table></figure></p><h2 id="1-6-嵌套列表"><a href="#1-6-嵌套列表" class="headerlink" title="1.6 嵌套列表"></a>1.6 嵌套列表</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x = [a, n]</span><br><span class="line">print(x)</span><br><span class="line">print(x[<span class="number">0</span>])</span><br><span class="line">print(x[<span class="number">0</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><h2 id="1-7-列表函数-amp-方法"><a href="#1-7-列表函数-amp-方法" class="headerlink" title="1.7 列表函数&amp;方法"></a>1.7 列表函数&amp;方法</h2><p>Python包含以下列表函数:</p><p>list参数 均为列表名称</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td>len(list) 列表元素个数</td></tr><tr><td>2</td><td>max(list) 返回列表元素最大值</td></tr><tr><td>3</td><td>min(list) 返回列表元素最小值</td></tr><tr><td>4</td><td>list(tuple) 将列表转换为元组。</td></tr></tbody></table><table><thead><tr><th>序号</th><th>方法</th></tr></thead><tbody><tr><td>1</td><td>list.append(obj) 在列表末尾添加新的对象</td></tr><tr><td>2</td><td>list.count(obj) 统计某个元素在列表中出现的次数</td></tr><tr><td>3</td><td>list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>4</td><td>list.index(obj)] 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>5</td><td>list.insert(index, obj) 将对象插入列表</td></tr><tr><td>6</td><td>list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>7</td><td>list.remove(obj) 移除列表中某个值的第一个匹配项</td></tr><tr><td>8</td><td>list.reverse() 反向列表中元素</td></tr><tr><td>9</td><td>list.sort([func]) 对原列表进行排序</td></tr><tr><td>10</td><td>list.clear() 清空列表</td></tr><tr><td>11</td><td>list.copy() 复制列表</td></tr></tbody></table><h1 id="2-Python3-元组"><a href="#2-Python3-元组" class="headerlink" title="2 Python3 元组"></a>2 Python3 元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。<br>元组使用<strong>小括号</strong>，列表使用<strong>方括号</strong>。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>);</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> );</span><br><span class="line">tup3 =  <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>; <span class="comment"># 不需要括号也可以</span></span><br><span class="line">print(type(tup3))</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="number">50</span>) </span><br><span class="line">print(type(tup1))     <span class="comment"># 不加逗号，类型为整型 </span></span><br><span class="line">tup1 = (<span class="number">50</span>,) </span><br><span class="line">print(type(tup1))     <span class="comment"># 加上逗号，类型为元组</span></span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt; </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-1-访问元组"><a href="#2-1-访问元组" class="headerlink" title="2.1 访问元组"></a>2.1 访问元组</h2><p>元组可以使用下标索引来访问元组中的值<br>例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="number">2015</span>, <span class="number">2016</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup2[1:5]: "</span>, tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tup1</span><span class="selector-attr">[0]</span>:  <span class="selector-tag">Sony</span></span><br><span class="line"><span class="selector-tag">tup2</span><span class="selector-attr">[1:5]</span>:  (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-1-修改元组"><a href="#2-1-修改元组" class="headerlink" title="2.1 修改元组"></a>2.1 修改元组</h2><p><strong>元组中的元素值是不允许修改的</strong>，但我们可以对元组进行连接组合<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>);</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2;</span><br><span class="line"><span class="keyword">print</span> (tup3)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">12</span>, <span class="number">34.56</span>, <span class="symbol">'abc</span>', <span class="symbol">'xyz</span>')</span><br></pre></td></tr></table></figure></p><h2 id="2-2-删除元组"><a href="#2-2-删除元组" class="headerlink" title="2.2 删除元组"></a>2.2 删除元组</h2><p><strong>元组中的元素值是不允许删除的</strong>，但我们可以使用del语句来删除整个元组例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">tup0 = (<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="number">2015</span>, <span class="number">2016</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (tup0)</span><br><span class="line"><span class="keyword">del</span> tup0;</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"删除后的元组 tup0 : "</span>)</span><br><span class="line"><span class="keyword">print</span> (tup0)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除后的元组 tup0 :</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"e:/Python3 Study/test.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print (tup0)</span><br><span class="line">NameError: <span class="keyword">name</span> <span class="string">'tup0'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p><h2 id="2-3-元组运算符"><a href="#2-3-元组运算符" class="headerlink" title="2.3 元组运算符"></a>2.3 元组运算符</h2><p>列表对 <code>+</code>和 <code>*</code> 的操作符与字符串相似。<code>+</code> 号用于组合列表，<code>*</code>号用于重复列表，<code>in</code>判断元素是否存在于列表中，<code>for</code>起迭代作用<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">print(len((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">print((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">print((<span class="string">'Fuck!'</span>) *  <span class="number">6</span>)</span><br><span class="line">print(<span class="number">3</span>  <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>): print(x, end=<span class="string">""</span>)<span class="comment">#end起不换行的作用</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">Fuck!Fuck!Fuck!Fuck!Fuck!Fuck!</span><br><span class="line">True</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></p><h2 id="2-4-元组索引，截取"><a href="#2-4-元组索引，截取" class="headerlink" title="2.4 元组索引，截取"></a>2.4 元组索引，截取</h2><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">L=(<span class="string">'Sony'</span>, <span class="string">'Apple'</span>, <span class="string">'Samsung'</span>)</span><br><span class="line">print(L[<span class="number">2</span>])</span><br><span class="line">print(L[<span class="number">-2</span>])<span class="comment">#从右侧开始读取倒数第二个元素</span></span><br><span class="line">print(L[<span class="number">-3</span>])</span><br><span class="line">print(L[<span class="number">1</span>:])<span class="comment">#输出从第二个元素开始后的所有元素</span></span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Samsung</span></span><br><span class="line"><span class="selector-tag">Apple</span></span><br><span class="line"><span class="selector-tag">Sony</span></span><br><span class="line">(<span class="string">'Apple'</span>, <span class="string">'Samsung'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-5-元组内置函数"><a href="#2-5-元组内置函数" class="headerlink" title="2.5 元组内置函数"></a>2.5 元组内置函数</h2><p>tuple参数 均为列表名称</p><table><thead><tr><th>序号</th><th>函数</th></tr></thead><tbody><tr><td>1</td><td>len(tuple) 列表元素个数</td></tr><tr><td>2</td><td>max(tuple) 返回列表元素最大值</td></tr><tr><td>3</td><td>min(tuple) 返回列表元素最小值</td></tr><tr><td>4</td><td>tuple(list) 将列表转换为元组。</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3基础知识1</title>
      <link href="/2018/04/17/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/"/>
      <url>/2018/04/17/Python3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
      <content type="html"><![CDATA[<h1 id="1-Hello-world"><a href="#1-Hello-world" class="headerlink" title="1 Hello world"></a>1 Hello world</h1><p>以下是Python3打印输出的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">print(&quot;Hello, World!&quot;);</span><br></pre></td></tr></table></figure></p><p>对于第一行代码 <code>#!/usr/bin/env python</code> </p><ul><li>如在终端果使用 <code>python test.py</code> 调用，则第一行代码被忽略，相当于注释。</li><li>如果在终端使用 <code>./test.py</code> 调用，则第一行代码这是指定解释器的类型。</li><li>第一行代码其实还可以写成 <code>#!/usr/bin/python</code> ，而这样是告诉操作系统直接调用/usr/bin下的python解释器，但是如果加上了<code>env</code>相当于告诉操作系统先去环境变量中找python的路径，再调用路径下的解释器，所以不加<code>env</code>则相当于把路径写死了，一般推荐加上<code>env</code>的写法。</li></ul><a id="more"></a><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2 基础知识"></a>2 基础知识</h1><h2 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1 编码"></a>2.1 编码</h2><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。<br>如果需要不同的编码，如使用GBK编码则在文件开头插入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: gbk -*-</span><br></pre></td></tr></table></figure></p><h2 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h2><ul><li>第一个字符必须是字母表中字母或下划线 _ 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li><strong>*标识符对大小写敏感</strong>。</li><li>Python 3 中，允许非 ASCII 标识符。</li></ul><h2 id="2-3-保留字"><a href="#2-3-保留字" class="headerlink" title="2.3 保留字"></a>2.3 保留字</h2><p><code>keyword.kwlist</code>是python的标准库提供的一个模块，可输出当前版本所有保留关键字。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import keyword</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; keyword.kwlist</span><br><span class="line">[<span class="string">'False'</span>, <span class="string">'None'</span>, <span class="string">'True'</span>, <span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'nonlocal'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-4-分号"><a href="#2-4-分号" class="headerlink" title="2.4 分号"></a>2.4 分号</h2><p>Python主要是靠换行来区分代码语句，一般来说<code>；</code>可加可不加，如果一行有多个代码语句，就要加上<code>；</code></p><h2 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h2><p>注释可以使用 <code>#</code> 、<code>&#39;&#39;&#39;</code>、<code>&quot;&quot;&quot;</code> ：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#注释1</span></span><br><span class="line"><span class="comment">#注释2</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">注释3</span></span><br><span class="line"><span class="string">注释4</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注释5</span></span><br><span class="line"><span class="string">注释6</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"Hello Python"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-6-行与缩进"><a href="#2-6-行与缩进" class="headerlink" title="2.6 行与缩进"></a>2.6 行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号<code>{}</code> 。</p><p>以下代码没问题<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第5行缩进不对就会报错<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"> <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第3行缩进不对也会报错<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>以下代码第4、5行缩进相同不会报错，但是第4、5行缩进不能与第3行相同<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="builtin-name">print</span> (<span class="string">"\nTrue\n"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br><span class="line">  <span class="builtin-name">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure></p><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠<code>\</code>来实现多行语句，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum = a + \</span><br><span class="line">      b + \</span><br><span class="line">      c</span><br></pre></td></tr></table></figure></p><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠<code>\</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,</span><br><span class="line"><span class="string">'d'</span>,<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="2-7-数字类型"><a href="#2-7-数字类型" class="headerlink" title="2.7 数字类型"></a>2.7 数字类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li><strong>bool</strong> (布尔), 如 True。</li><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><h2 id="2-8-字符串"><a href="#2-8-字符串" class="headerlink" title="2.8 字符串"></a>2.8 字符串</h2><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘\’</li><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'字符串'</span> </span><br><span class="line">sentence = <span class="string">"这是一个句子。"</span> </span><br><span class="line">paragraph = <span class="string">"""这是一个段落， </span></span><br><span class="line"><span class="string">可以由多行组成"""</span></span><br></pre></td></tr></table></figure></li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line">str=<span class="string">'Helloa'</span>  </span><br><span class="line">print(str)       <span class="comment"># 输出字符串 </span></span><br><span class="line">print(str[<span class="number">0</span>:<span class="number">-1</span>]) <span class="comment"># 输出第一个到倒数第二个的所有字符 </span></span><br><span class="line">print(str[<span class="number">0</span>])        <span class="comment"># 输出字符串第一个字符 </span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>])    <span class="comment"># 输出从第三个开始到第五个的字符 </span></span><br><span class="line">print(str[<span class="number">2</span>:])     <span class="comment"># 输出从第三个开始的后的所有字符 </span></span><br><span class="line">print(str * <span class="number">2</span>)     <span class="comment"># 输出字符串两次 </span></span><br><span class="line">print(str + <span class="string">'你好'</span>)     <span class="comment"># 连接字符串  </span></span><br><span class="line">print(<span class="string">'------------------------------'</span>) </span><br><span class="line">print(<span class="string">'hello\nrunoob'</span>)    <span class="comment"># 使用反斜杠(\)+n转义特殊字符 </span></span><br><span class="line">print(<span class="string">r'hello\nrunoob'</span>)   </span><br><span class="line"><span class="comment">#在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure></p><p>输出结果为：</p><pre><code>HelloaHelloHllolloaHelloaHelloaHelloa你好------------------------------helloareyouokhello\nareyouok</code></pre><h2 id="2-9-空行"><a href="#2-9-空行" class="headerlink" title="2.9  空行"></a>2.9  空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。<br>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。<br><strong>记住：</strong>空行也是程序代码的一部分。</p><h2 id="2-10-用户输入"><a href="#2-10-用户输入" class="headerlink" title="2.10 用户输入"></a>2.10 用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line">input(<span class="string">"\n\n按下 enter 键后退出。"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-11-多个语句构成代码组"><a href="#2-11-多个语句构成代码组" class="headerlink" title="2.11 多个语句构成代码组"></a>2.11 多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :     </span><br><span class="line">suite </span><br><span class="line"><span class="keyword">elif</span> expression :     </span><br><span class="line">suite  </span><br><span class="line"><span class="keyword">else</span> :     </span><br><span class="line">suite</span><br></pre></td></tr></table></figure></p><h2 id="2-12-Print-输出"><a href="#2-12-Print-输出" class="headerlink" title="2.12 Print 输出"></a>2.12 Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=””</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line">x=<span class="string">"a"</span> </span><br><span class="line">y=<span class="string">"b"</span> </span><br><span class="line"><span class="comment"># 换行输出 </span></span><br><span class="line">print( x ) </span><br><span class="line">print( y )  </span><br><span class="line">print(<span class="string">'---------'</span>) <span class="comment"># 不换行输出 </span></span><br><span class="line">print( x, end=<span class="string">" "</span> ) </span><br><span class="line">print( y, end=<span class="string">" "</span> ) </span><br><span class="line">print()</span><br></pre></td></tr></table></figure></p><p> 执行后为：<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> </span><br><span class="line"><span class="selector-tag">b</span> --------- </span><br><span class="line"><span class="selector-tag">a</span> b</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3，基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探究Lv_group</title>
      <link href="/2018/04/15/%E6%8E%A2%E7%A9%B6lv_group%E6%96%87%E4%BB%B6/"/>
      <url>/2018/04/15/%E6%8E%A2%E7%A9%B6lv_group%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-group的作用"><a href="#1-lv-group的作用" class="headerlink" title="1 lv_group的作用"></a>1 lv_group的作用</h1><p>在LittlevGL的全局设置中可以看到(如下图)，lv_group是keyboards的扩展功能。<br><img src="http://mypic666.test.upcdn.net/20180424153733.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>在演示程序中可以看到，通过“Next”按键可以控制群对象中的对象之间的切换，类似于电脑上的“Tab键”控制窗口上的菜单之间的切换<br><img src="http://mypic666.test.upcdn.net/20180424164342.png" alt=""></p><a id="more"></a><p><img src="http://mypic666.test.upcdn.net/20180424224107.png" alt=""><br><img src="http://mypic666.test.upcdn.net/20180424224141.png" alt=""></p><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>可以在演示程序的主初始化模块中看到其创建了一个群对象</p><p><img src="http://mypic666.test.upcdn.net/20180424170731.png" alt=""></p><p>并且在群对象中加入了子对象</p><p><img src="http://mypic666.test.upcdn.net/20180424172848.png" alt=""></p><p>以此实现了多个子对象组件成了群对象</p><h1 id="4-程序"><a href="#4-程序" class="headerlink" title="4 程序"></a>4 程序</h1><p>下面是群对象的结构体，可以看到第一个就是预先定义的链表结构体</p><p><img src="http://mypic666.test.upcdn.net/20180424175144.png" alt=""></p><p>通过lv_group群对象创建的源代码可以知道，首先使用了群对象的结构体大小在内存中申请了一部分空间，并且使用群对象结构体中的链表结构体的指针做头结点初始化了一个新的双向链表。</p><p><img src="http://mypic666.test.upcdn.net/20180424174354.png" alt=""></p><p>而在群对象中添加子对象的做法是在一个双向链表的尾部创建一个节点，并且将子对象的指针赋给这个节点。如果当前的结点的后继与当前链表的第一个节点的指针相同，则说明只有一个结点，同时使用<code>lv_group_focus_next()</code>在当前节点的后继创建临时的指针，待下一个子对象的指针的值赋给它。</p><p><img src="http://mypic666.test.upcdn.net/20180424200546.png" alt=""></p><p>这个双向链表的尾部创建一个节点，同样的还有<code>lv_ll_ins_head()</code> ,即在双向链表的头部创建一个结点，与下列代码大致相似。</p><p><img src="http://mypic666.test.upcdn.net/20180424215219.png" alt=""></p><p>这个是将当前的焦点转移到双向链表的下一个结点。</p><p><img src="http://mypic666.test.upcdn.net/20180424201542.png" alt=""></p><p>这样一来，群对象相当与一个链表，各个子对象相当于结点，随意切换到当前子对象的上一个或者下一个子对象都很方便。</p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LittlevGL新版字库图片转换器</title>
      <link href="/2018/04/12/LittlevGL%E6%96%B0%E7%89%88%E5%AD%97%E5%BA%93%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2018/04/12/LittlevGL%E6%96%B0%E7%89%88%E5%AD%97%E5%BA%93%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="1-PHP-环境安装"><a href="#1-PHP-环境安装" class="headerlink" title="1 PHP 环境安装"></a>1 PHP 环境安装</h1><h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h2><p>下面是 PHP7.2 的 windows 64位非安全线程版<br><a href="https://windows.php.net/downloads/releases/php-7.2.4-nts-Win32-VC15-x64.zip" target="_blank" rel="noopener">VC15 x64 Non Thread Safe</a></p><h2 id="1-2-安装环境"><a href="#1-2-安装环境" class="headerlink" title="1.2 安装环境"></a>1.2 安装环境</h2><ul><li><p>将下载后的压缩包解压</p></li><li><p>在系统变量中添加解压后的文件夹的路径，如图所示<br><img src="http://mypic666.test.upcdn.net/20180420205557.png" alt=""></p></li><li><p>变量中php文件夹的根目录与php文件夹中的扩展目录都要添加上去<br><img src="http://mypic666.test.upcdn.net/20180420205842.png" alt=""></p></li><li><p>将php根目录中的 <code>php.ini-development</code> 文件 改名为 <code>php.ini</code></p></li></ul><a id="more"></a><ul><li><p>在 <code>php.ini</code> 文本中找到 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="attribute">extension</span>=gd2</span><br></pre></td></tr></table></figure></li></ul><p>并且将<code>;</code>去掉</p><ul><li>再找到<code>;extension_dir=&quot;tmp&quot;</code>,将<code>;</code>去掉，并将值改为你的php根目录中扩展目录的路径<br>如<code>extension_dir = &quot;C:\php-7.2.4\ext&quot;</code></li><li>在dos中输入 <code>php -v</code> 出现如下内容便是搭建成功<br><img src="http://mypic666.test.upcdn.net/20180420211304.png" alt=""><h1 id="2-字库以及图片的生成"><a href="#2-字库以及图片的生成" class="headerlink" title="2 字库以及图片的生成"></a>2 字库以及图片的生成</h1><h2 id="2-1-获取新版转换工具"><a href="#2-1-获取新版转换工具" class="headerlink" title="2.1 获取新版转换工具"></a>2.1 获取新版转换工具</h2>以下是新版转换工具的地址，将其git下来<br><a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:littlevgl/lv_utils.git`<h2 id="2-2-字库的转换"><a href="#2-2-字库的转换" class="headerlink" title="2.2 字库的转换"></a>2.2 字库的转换</h2></li><li>git下来的目录中可以看到<code>font_conv_core.php</code>这个文件，此文件便是用来转换字库的。</li><li>打开dos并且cd到当前目录中</li><li>将你需要转换的xxx.ttf文件复制到当前目录中</li><li><p>在dos中输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php font_conv_core<span class="selector-class">.php</span> <span class="string">"name=testFONT&amp;font=xxx.ttf&amp;height=20&amp;bpp=4&amp;uni_first=32&amp;uni_last=126&amp;list=%2B-0123456789&amp;built_in=0"</span></span><br></pre></td></tr></table></figure></li><li><p>参数<br><strong>name</strong>：要生成的字库文件的字库名以及其文件名<br><strong>font</strong>：同目录下的tff文件名<br><strong>height</strong>：字体高度<br><strong>bpp</strong>：每像素bit大小（1,2,4,8 四种）<br><strong>uni_first</strong>：选择的unicode开始范围一般为32<br><strong>last_first</strong>：选择的unicode结束范围一般为40869<br><strong>built_in</strong>：是否将其设置为内建字库，即1,2,4,8 bpp都生成<br><strong>list</strong>：输入你要转换的字符如 abcdefg123456你好</p></li><li><p>执行后会在当前目录中生成一个testFONT.c文件，此便是生成的字库</p></li></ul><h2 id="2-3-图片的转换"><a href="#2-3-图片的转换" class="headerlink" title="2.3 图片的转换"></a>2.3 图片的转换</h2><ul><li>在当前目录下可以看到<code>img_conv_core.php</code>文件，此便是图片转换文件。</li><li>将需要转换的图片复制到当前目录，如 xxx.png<br><strong>注意，仅支持BMP，JPG，PNG三种图片格式</strong></li><li><p>将doscd到当前目录下，输入如下命令 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php img_conv_core<span class="selector-class">.php</span> <span class="string">"name=testIMG&amp;img=xxx.png&amp;format=c_array&amp;transp=alpha"</span></span><br></pre></td></tr></table></figure></li><li><p>参数：<br><strong>name</strong>：要生成的文件名<br><strong>img</strong>：当前目录下的源文件名称<br><strong>format</strong>：转换格式，有<code>c_array</code>, <code>bin_rgb332</code>,  <code>bin_rgb565</code>, <code>bin_rgb888</code> 四种，默认是<code>c_array</code><br><strong>transp</strong>：透明设置，有<code>none</code>,<code>alpha</code>,<code>chroma</code>三种，一般选择<code>alpha</code>,默认为<code>none</code></p></li><li>执行后当前目录下生成的testIMG.c文件便是转换后的图片</li></ul>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 字库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_refr的探究</title>
      <link href="/2018/03/21/lv_refr%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/21/lv_refr%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-refr的作用"><a href="#1-lv-refr的作用" class="headerlink" title="1 lv_refr的作用"></a>1 lv_refr的作用</h1><p>在 lv_conf 中可以看到如下宏定义，表示定义屏幕刷新周期的时间，单位为毫秒<br><img src="http://mypic666.test.upcdn.net/20180504232842.png" alt=""></p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>与 lv_indev 相似，数值越大视觉感受越差</p><ul><li>当<code>#define LV_REFR_PERIOD 1</code>的时候，在屏幕上滑动列表，感觉滑动的效果会比较流畅。</li><li>当<code>#define LV_REFR_PERIOD 40</code>的时候，在屏幕上滑动列表，感觉滑动的效果有明显的卡顿感，如果数值大于<code>LV_INDEV_READ_PERIOD</code>的数值，这会有非常明显的卡顿感。</li></ul><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>可以看到 lv_refr 的初始化函数与 lv_indev 的初始化函数很像，也是创建一个任务，通过周期性的调用任务内的函数来实现屏幕的显示刷新<br><img src="http://mypic666.test.upcdn.net/20180504221318.png" alt=""></p><p>任务中调用的函数如下，首先是获取定时器的消息，并且将刷新缓冲区的内存清零<br><img src="http://mypic666.test.upcdn.net/20180504222026.png" alt=""></p><p>下面是将待刷新的区域加入到缓冲区<br><img src="http://mypic666.test.upcdn.net/20180504230409.png" alt=""></p><p>下面是刷新缓冲区：<br><img src="http://mypic666.test.upcdn.net/20180504231419.png" alt=""></p><p>如果定义了虚拟缓冲区，则会调用下面的函数<br><img src="http://mypic666.test.upcdn.net/20180504232110.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，屏幕刷新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浮点数、定点数</title>
      <link href="/2018/03/21/%E6%B5%AE%E7%82%B9%E6%95%B0%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0/"/>
      <url>/2018/03/21/%E6%B5%AE%E7%82%B9%E6%95%B0%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="什么是定点数"><a href="#什么是定点数" class="headerlink" title="什么是定点数"></a>什么是定点数</h1><h2 id="通俗的解释"><a href="#通俗的解释" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p>​    定点数指小数点在数中的位置是固定不变的，通常有定点整数和定点小数。在对小数点位置作出选择之后，运算中的所有数均应统一为定点整数或定点小数，在运算中不再考虑小数问题。</p><a id="more"></a> <p>​    以人民币为例，我们日常经常说到的如123.45￥，789.34￥等等，默认的情况下，小数点后面有两位小数，即角，分。如果小数点在最高有效位的前面，则这样的数称为纯小数的定点数，如0.12345，0.78934等。如果小数点在最低有效位的后面，则这样的数称为纯整数的定点数，如12345，78934等。</p><h2 id="专业的说法"><a href="#专业的说法" class="headerlink" title="专业的说法"></a>专业的说法</h2><p>​    所谓定点格式，即<strong><em>约定机器中所有数据的小数点位置是固定不变的</em></strong>。通常将定点数据表示成纯小数或纯整数，为了将数表示成纯小数，通常把小数点固定在数值部分的最高位之前；而为了将数表示成纯整数，则把小数点固定在数值部分的最后面，如下图所示：</p><p><img src="http://mypic666.test.upcdn.net/052235097517088.png" alt=""></p><h1 id="什么是浮点数"><a href="#什么是浮点数" class="headerlink" title="什么是浮点数"></a>什么是浮点数</h1><h2 id="通俗的解释-1"><a href="#通俗的解释-1" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p>​    浮点数：一般说来，小数点不固定的数。比较容易的理解方式是，考虑以下我们日常见到的科学记数法，拿我们上面的数字举例，如123.45，可以写成以下几种形式</p><p>如：</p><p>12.345x10^1^</p><p>1.2345 x10^2^</p><p>0.12345 x10^3^</p><p>……</p><p>为了表示一个数，小数点的位置可以变化，即小数点不固定。</p><h2 id="专业的说法-1"><a href="#专业的说法-1" class="headerlink" title="专业的说法"></a>专业的说法</h2><p>​    定点数表示法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大或特别小的数，最终，绝大多数现代的计算机系统采纳了浮点数表达方式，这种表达方式利用科学计数法来表达实数，即用一个尾数(Mantissa，尾数有时也称为<strong><em>有效数字</em></strong>，它实际上是有效数字的非正式说法)，一个基数(Base)，一个指数(Exponent)以及一个表示正负的符号来表达实数，比如123.45用十进制科学计数法可以表示为1.2345x10^2^，其中1.2345为尾数，10为基数，2为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。</p><h1 id="定点数与浮点数的对比"><a href="#定点数与浮点数的对比" class="headerlink" title="定点数与浮点数的对比"></a>定点数与浮点数的对比</h1><p>​    定点表示法运算直观，但数的表示范围较小，不同的数运算时要考虑比例因子的选取，以防止溢出。浮点表示法运算时可以不考虑溢出，但浮点运算，编程较难。要掌握定、浮点数的转换方法及浮点数规格化方法。</p><h2 id="表示的精度与范围不同"><a href="#表示的精度与范围不同" class="headerlink" title="表示的精度与范围不同"></a>表示的精度与范围不同</h2><p>​    例如，我们用4个十进制数来表达一个数字。对于定点数（这里以定点整数为例），我们表示区间[0000，9999]中的任何一个数字，但是如果我们要想表示类似1234.3的数值就无能为力了，因为此时的表示精度为1/10^0^=1；如果采用浮点数来表示（以归整的科学记数法，即小数点前有一位有效位，为例），则可以表示[0.000，9.999]之间的任何一个数字，表示的精度为1/10^3^=0.001，精度比上一种方式提高了很多，但是表示的范围却小了很多。</p><p>​    也就是说，一般的，定点数表示的精度较低，但表示的数值范围较大；而浮点数恰恰相反。</p><h2 id="计算机中运算的效率不同"><a href="#计算机中运算的效率不同" class="headerlink" title="计算机中运算的效率不同"></a>计算机中运算的效率不同</h2><p>​    一般说来，定点数的运算在计算机中实现起来比较简单，效率较高；而浮点数的运算在计算机中实现起来比较复杂，效率相对较低。</p><h2 id="硬件依赖性"><a href="#硬件依赖性" class="headerlink" title="硬件依赖性"></a>硬件依赖性</h2><p>​    一般说来，只要有硬件提供运算的部件，就会提供定点数运算的支持（不知道说的确切否，没有听说过不支持定点数运算的硬件），但不一定支持浮点数运算，如有的很多嵌入式开发板就不提供浮点运算的支持。</p><h1 id="浮点数的存储格式"><a href="#浮点数的存储格式" class="headerlink" title="浮点数的存储格式"></a>浮点数的存储格式</h1><h2 id="IEEE-浮点格式规范"><a href="#IEEE-浮点格式规范" class="headerlink" title="IEEE 浮点格式规范"></a>IEEE 浮点格式规范</h2><p>​    浮点数的小数点是不固定的，如果每个人都按照自己的爱好存储在电脑里，那不就乱套了吗？那么怎么在计算机中存储这种类型的数字呢？象这类古老的问题前人早都为我们做好了相应的规范，无规矩不成方圆吗。我们平时所说的浮点数的存储规范，就是由IEEE指定的，具体的规范文件是：IEEE Standard 754 for Binary Floating-Point Arithmetic。大家可以很容易的从网络上下载到这篇文档。</p><h2 id="单精度浮点"><a href="#单精度浮点" class="headerlink" title="单精度浮点"></a>单精度浮点</h2><p>在c语言中，<strong>单精度（float）数据类型为32bits</strong>，具体的如下图所示：</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102352889.png" alt=""></p><p><strong>整个32bits分三部分，即</strong></p><p>　　Sign：符号位，1 bit，0为正，1为负；</p><p>　　Exponent(bias)：指数部分，8 bits，存储格式为移码存储（后面还会说明），偏移量为127；</p><p>　　Mantissa(fraction)：尾数部分。</p><h2 id="双精度浮点"><a href="#双精度浮点" class="headerlink" title="双精度浮点"></a>双精度浮点</h2><p>　　<strong>对应的双精度（double）类型的格式为：</strong></p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102402031.png" alt=""></p><p>​    同样，64位也被分为了三部分，对照单精度，不用我说就可以理解各个部分的含义了吧？</p><p>　　是不是有点迷糊了，不要怕，理论这个东西最能忽悠人了，看起来很高深，其实也就是个屁大的事，举个例子就很容易明白了。</p><p>举例说明，如3.24x10^3^，则对应的部分为，Sign为0，3为指数部分（注意计算机里面存储的不是3，这里仅仅为了说明），3.24为尾数。我们知道，计算机“笨”的要死，只认识0和1，那么到底一个浮点数值在计算机存储介质中是如何存储的呢？</p><p>例如，我们要想偷窥浮点类型的值4.25在计算机硬盘中存储的庐山真面目，请跟我来：首先把4.25转换成二进制的表达方式，即100.01，在详细点，变成1.0001x2^2^，好了，对号入座把。</p><p>Sign=0;</p><p>Exponent(bias)=2+127=129 （偏移量为127，就是直接加上个127了）；</p><p>Mantissa=1.0001-1.0=0001（规格化后，小数点前总是整数1，全世界人都知道前面是1不是0，所以省略不写了，即尾数部分不包括整数部分；当别人问你，为什么23 bit的尾数部分可以表示24位的精度，知道怎么回答了吧。 靠，什么，没有看懂，再仔细读两便就知道了）。</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102409132.png" alt=""></p><p>​    对照上面的图示，相信你已经看明白了吧？相信你的智商。为了加深认识，再来一个。如果给定你一个二进制数字串</p><p>01000000100010000000000000000000</p><p>并告诉你这是一个float类型的值，让你说出它是老几，知道怎么算了吧？如果不知道，看下面的图，我就不废话解释了。</p><p><img src="http://files.jb51.net/file_images/article/201606/2016617102421605.png" alt=""></p><h1 id="浮点定点转换"><a href="#浮点定点转换" class="headerlink" title="浮点定点转换"></a>浮点定点转换</h1><h2 id="Q格式定标法"><a href="#Q格式定标法" class="headerlink" title="Q格式定标法"></a>Q格式定标法</h2><p>​    通过假定小数点位于哪一位(Q)的右侧，从而确定小数的精度，以下为32位数Q定标表格。</p><table><thead><tr><th style="text-align:center">Q表示</th><th style="text-align:center">十进制浮点数表示范围</th><th style="text-align:center">精度</th></tr></thead><tbody><tr><td style="text-align:center">Q=31</td><td style="text-align:center">-1≤x≤0.999 999 999</td><td style="text-align:center">2^(-31)</td></tr><tr><td style="text-align:center">Q=30</td><td style="text-align:center">-2≤x≤1.999 999 999</td><td style="text-align:center">2^(-30)</td></tr><tr><td style="text-align:center">Q=29</td><td style="text-align:center">-4≤x≤3.999 999 998</td><td style="text-align:center">2^(-29)</td></tr><tr><td style="text-align:center">Q=28</td><td style="text-align:center">-8≤x≤7.999 999 996</td><td style="text-align:center">2^(-28)</td></tr><tr><td style="text-align:center">Q=27</td><td style="text-align:center">-16≤x≤15.999 999 993</td><td style="text-align:center">2^(-27)</td></tr><tr><td style="text-align:center">Q=26</td><td style="text-align:center">-32≤x≤31.999 999 985</td><td style="text-align:center">2^(-26)</td></tr><tr><td style="text-align:center">Q=25</td><td style="text-align:center">-64≤x≤63.999 999 970</td><td style="text-align:center">2^(-25)</td></tr><tr><td style="text-align:center">Q=24</td><td style="text-align:center">-128≤x≤127.999 999 940</td><td style="text-align:center">2^(-24)</td></tr><tr><td style="text-align:center">Q=23</td><td style="text-align:center">-256≤x≤255.999 999 981</td><td style="text-align:center">2^(-23)</td></tr><tr><td style="text-align:center">Q=22</td><td style="text-align:center">-512≤x≤511.999 999 762</td><td style="text-align:center">2^(-22)</td></tr><tr><td style="text-align:center">Q=21</td><td style="text-align:center">-1024≤x≤1023.999 999 523</td><td style="text-align:center">2^(-21)</td></tr><tr><td style="text-align:center">Q=20</td><td style="text-align:center">-2048≤x≤2047.999 999 046</td><td style="text-align:center">2^(-20)</td></tr><tr><td style="text-align:center">Q=19</td><td style="text-align:center">-4096≤x≤4095.999 998 093</td><td style="text-align:center">2^(-19)</td></tr><tr><td style="text-align:center">Q=18</td><td style="text-align:center">-8192≤x≤8191.999 996 185</td><td style="text-align:center">2^(-18)</td></tr><tr><td style="text-align:center">Q=17</td><td style="text-align:center">-16384≤x≤16363.999 992 371</td><td style="text-align:center">2^(-17)</td></tr><tr><td style="text-align:center">Q=16</td><td style="text-align:center">-32768≤x≤32767.999 984 741</td><td style="text-align:center">2^(-16)</td></tr><tr><td style="text-align:center">Q=15</td><td style="text-align:center">-65536≤x≤65535.999 969 482</td><td style="text-align:center">2^(-15)</td></tr><tr><td style="text-align:center">Q=14</td><td style="text-align:center">-131072≤x≤131071.999 938 965</td><td style="text-align:center">2^(-14)</td></tr><tr><td style="text-align:center">Q=13</td><td style="text-align:center">-262144≤x≤262143.999 877 930</td><td style="text-align:center">2^(-13)</td></tr><tr><td style="text-align:center">Q=12</td><td style="text-align:center">-5244288≤x≤524287.999 755 859</td><td style="text-align:center">2^(-12)</td></tr><tr><td style="text-align:center">Q=11</td><td style="text-align:center">-1048576≤x≤1048575.999 511 719</td><td style="text-align:center">2^(-11)</td></tr><tr><td style="text-align:center">Q=10</td><td style="text-align:center">-2097152≤x≤2097151.999 511 719</td><td style="text-align:center">2^(-10)</td></tr><tr><td style="text-align:center">Q=9</td><td style="text-align:center">-4194304≤x≤4194302.998 046 875</td><td style="text-align:center">2^(-9)</td></tr><tr><td style="text-align:center">Q=8</td><td style="text-align:center">-8388608≤x≤8388607.996 093 750</td><td style="text-align:center">2^(-8)</td></tr><tr><td style="text-align:center">Q=7</td><td style="text-align:center">-16777216≤x≤16777215.992 187 500</td><td style="text-align:center">2^(-7)</td></tr><tr><td style="text-align:center">Q=6</td><td style="text-align:center">-33554432≤x≤33554431.984 375 000</td><td style="text-align:center">2^(-6)</td></tr><tr><td style="text-align:center">Q=5</td><td style="text-align:center">-67108864≤x≤67108863.968 750 000</td><td style="text-align:center">2^(-5)</td></tr><tr><td style="text-align:center">Q=4</td><td style="text-align:center">-134217728≤x≤134217727.937 500 000</td><td style="text-align:center">2^(-4)</td></tr><tr><td style="text-align:center">Q=3</td><td style="text-align:center">-268435456≤x≤268435455.875 000 000</td><td style="text-align:center">2^(-3)</td></tr><tr><td style="text-align:center">Q=2</td><td style="text-align:center">-536870912≤x≤536870911.750 000 000</td><td style="text-align:center">2^(-2)</td></tr><tr><td style="text-align:center">Q=1</td><td style="text-align:center">-1073741824≤x≤1073741823.500 000 000</td><td style="text-align:center">2^(-1)</td></tr><tr><td style="text-align:center">Q=0</td><td style="text-align:center">-2147483648≤x≤2147483647</td><td style="text-align:center">2^0</td></tr></tbody></table><h2 id="转换关系"><a href="#转换关系" class="headerlink" title="转换关系"></a>转换关系</h2><p>浮点数(X)转换为定点数(Xq)：<code>Xq=(int)X* 2^Q</code></p><p>定点数(Xq)转换为浮点数(X)：<code>X=(float)Xq*2^(-Q)</code></p><p><strong>Example:</strong></p><p>将浮点数X = 0.5转换为32位Q定标的定点数：</p><ul><li><p><strong>(1)由于-1≤X≤0.999 999 999</strong>，按照上述表格所以我们取Q = 31，</p><p>即定点数：Xq=(int)X<em> 2^Q = (int)(0.5 </em> 2^31) = 1073741842;</p><p>反之知道定点数Xq = 1073741842 反推其浮点数如下</p><p>则X=(float)Xq<em>2^(-Q) = (float)1073741842</em>2^(-31) = 0.5;</p><p>​    按照上述如果我们取Q = 31，如果我们要计算浮点的0.5<em>0.5，则相当于计算定点的1073741842 </em> 1073741842 这个数实在是太大了，只能用long long型装下，而非一个字(int)可以装下。通过观察0.5这个数我们只需要保证表格中的Q值对应的精度比0.5更小即可，如此我们重新选择Q：</p></li><li><p><strong>(2)由于-536870912≤x≤536870911.750 000 000</strong>，按照上述表格我们取Q = 2， 即定点数：Xq=(int)X<em> 2^Q = (int)(0.5 </em> 2^2) = 2; 反之知道定点数Xq = 2 反推其浮点数如下 则X=(float)Xq<em>2^(-2) = (float)2</em>2^(-2) = 0.5; 按照上述如果我们取Q = 2，如果我们要计算浮点的0.5<em>0.5，则相当于计算定点的2 </em> 2，一个char就可以装下了。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
            <tag> 定点数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_obj的探究</title>
      <link href="/2018/03/19/lv_obj%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/19/lv_obj%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-obj的作用"><a href="#1-lv-obj的作用" class="headerlink" title="1 lv_obj的作用"></a>1 lv_obj的作用</h1><p>obj 即 对象，也是LittlevGL中构成各种容器、页面、控件最基本的元素，就是说GUI中的各种元素都是在obj的基础上增加扩展功能或修改样式而来的。</p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>使用<code>lv_obj_create</code>创建一个基本的空对象并将其作为屏幕，其父级与样式复制都为NULL<br><img src="http://mypic666.test.upcdn.net/20180504175855.png" alt=""><br>效果：<br><img src="http://mypic666.test.upcdn.net/20180504180154.png" alt=""></p><a id="more"></a><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在 lv_obj.c 中可以看到，如果没有为对象设置父级，则会创建一个新的双向链表，并为双向链表申请内存空间，然后再定义这个对象的在屏幕上的尺寸的大小，同时也会获取当前设置的全局主题。<br><img src="http://mypic666.test.upcdn.net/20180504194605.png" alt=""></p><p>以及对一些属性的初始化设置<br><img src="http://mypic666.test.upcdn.net/20180504200138.png" alt=""></p><p>如果在创建对象的时候设置了父级，则会以父级对象结构体中预设的一个用于子对象创建头结点的指针来创建一个双向链表<br><img src="http://mypic666.test.upcdn.net/20180504200313.png" alt=""></p><p>如果样式复制的参数不为空的话，则会直接将被复制的对象的参数直接赋值给新建的这个对象<br><img src="http://mypic666.test.upcdn.net/20180504204922.png" alt=""></p><p>如果要删除一个对象，可以使用<code>lv_obj_del</code>函数，删除过程是通过以下代码实现的，可以看到对象的数据被标记为无效，然后再删除了其链表中的内容<br><img src="http://mypic666.test.upcdn.net/20180504210509.png" alt=""></p><p>标记对象数据为无效的过程如下，标为无效后在下一次刷新时，此对象的将被刷新掉<br><img src="http://mypic666.test.upcdn.net/20180504212037.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，对象创建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lv_style的探究</title>
      <link href="/2018/03/09/lv_style%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/03/09/lv_style%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-lv-style的作用"><a href="#1-lv-style的作用" class="headerlink" title="1 lv_style的作用"></a>1 lv_style的作用</h1><p>lv_style的作用是用来为对象设置样式风格。</p><h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2 效果"></a>2 效果</h1><p>如下图，比如下面的拖动条，是在设置了主题样式之后才有的这种视觉效果，其实LittlevGL默认就有一套固定的主题样式，如果你不设置主题样式，就会使用默认的主题样式，只是比较丑而已，也就是说，有了主题样式之后你才能看到这个对象的外观形态，否则是看不到的。<br><img src="http://mypic666.test.upcdn.net/20180507205941.png" alt=""><br><a id="more"></a></p><h1 id="3-实现过程"><a href="#3-实现过程" class="headerlink" title="3 实现过程"></a>3 实现过程</h1><p>在文件的开头设置了13个默认风格的样式<br><img src="http://mypic666.test.upcdn.net/20180507211158.png" alt=""></p><p>在初始化风格样式的时候，首先以 <code>lv_style_scr</code> 制定了第一种样式，也就是最基本的<br><img src="http://mypic666.test.upcdn.net/20180507211427.png" alt=""></p><p>而对于 <code>lv_style_plain</code> ，则是照搬 <code>lv_style_scr</code> 的设置，所以 <code>lv_style_plain</code> 与 <code>lv_style_scr</code> 可以说是一模一样的。<br><img src="http://mypic666.test.upcdn.net/20180507211700.png" alt=""></p><p>后面的做法也是一样，都是以 <code>lv_style_plain</code> 为基本模板，在此基础上修改风格样式。<br><img src="http://mypic666.test.upcdn.net/20180507211918.png" alt=""></p><p>再如透明的风格，就是将对象的“身体”设置为空，以及一些边框的宽度设置为0，使其看上去有透明的感觉<br><img src="http://mypic666.test.upcdn.net/20180507212237.png" alt=""></p><p>最后就是按钮的风格，“释放” 与 “按下” 两种风格，“释放”风格根据基本的模板风格来修改，而“按下”则根据“释放”的来修改<br><img src="http://mypic666.test.upcdn.net/20180507212623.png" alt=""></p><p>如果你想自定义自己喜欢的风格，可以以这13个样式风格为最基本的风格，自己新建一个样式风格的同时将基本的样式风格copy过来，再在新建的风格上进行修改。如下接口便提供这个功能，第一个参数是你新建的样式风格的名称，第二个参数是任意一个已存在的样式风格。<br><img src="http://mypic666.test.upcdn.net/20180507213018.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL，风格样式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win下LittlevGL模拟器环境的搭建</title>
      <link href="/2018/01/29/win%E4%B8%8BLittlevGL%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/01/29/win%E4%B8%8BLittlevGL%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h1><p>由于LittleVgl官方提供的Windows下的模拟环境为Eclipse工程，且模拟环境依赖SDL库运行</p><p>所以需要安装以下工具：</p><ul><li><p>MinGW</p></li><li><p>JDK</p></li><li><p>Eclipse CDT</p></li><li><p>SDL2</p></li></ul><h2 id="1-1-安装MinGW"><a href="#1-1-安装MinGW" class="headerlink" title="1.1 安装MinGW"></a>1.1 安装MinGW</h2><p>MinGW, 全称Minimalist GNU for Windows, 是GCC编译器和GNU Binutils在Windows平台的移植版本. MinGW-w64原是其分支, 后来成为独立发展的项目. 由于仅有MinGW-w64被GCC官方所支持, 而MinGW早已停止更新, 因此推荐使用MinGW-w64.</p><a id="more"></a><p><a href="https://sourceforge.net/projects/mingw-w64/files/latest/download" target="_blank" rel="noopener">MinGW-w64下载地址</a></p><ul><li><p>第一步.下载完成后打开安装程序点击下一步选择版本,并选择如下配置</p><p><img src="http://mypic666.test.upcdn.net/mg.png" alt=""></p></li></ul><ul><li><p>第二步.选择路径，记住你选的路径</p><p><img src="http://mypic666.test.upcdn.net/mg1.png" alt=""></p></li></ul><ul><li><p>第三步.安装完成后</p><p>点击 我的电脑&gt;右键属性进行下图设置</p><p><img src="http://mypic666.test.upcdn.net/341522-20180115192027256-1156620245.png" alt=""></p></li><li><p>最主要的是在系统变量的 Path 中加入  “你的路径\mingw64\bin”</p></li><li><p>完成配置之后打开CMD终端 输入 <code>gcc -v</code>,如下图显示即配置成功</p><p><img src="http://mypic666.test.upcdn.net/mgc.png" alt=""></p></li></ul><h2 id="1-2-安装JRE"><a href="#1-2-安装JRE" class="headerlink" title="1.2 安装JRE"></a>1.2 安装JRE</h2><p>因为安装Eclipse CDT需要Java运行环境所以需要安装JRE，建议下载JDK安装包，JDK安装包可以自动配置环境变量，JRE包需要手动配置，且JDK安装包内包含了JRE</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK下载地址</a></p><p><img src="http://mypic666.test.upcdn.net/jdk.png" alt=""></p><ul><li>选择你系统对应的版本下载</li><li>安装包下载完成后直接全部点击下一步直到安装完成即可</li></ul><h2 id="1-3-安装Eclipse-CDT"><a href="#1-3-安装Eclipse-CDT" class="headerlink" title="1.3 安装Eclipse CDT"></a>1.3 安装Eclipse CDT</h2><p><a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse inst下载地址</a></p><ul><li><p>下载完成后直接运行安装包</p></li><li><p>选择如图中的CDT套件</p><p><img src="http://mypic666.test.upcdn.net/cdt.png" alt=""></p></li><li><p>选择之后选择你的安装路径，随后等待安装完成即可使用</p></li></ul><h2 id="1-4-安装SDL2环境"><a href="#1-4-安装SDL2环境" class="headerlink" title="1.4 安装SDL2环境"></a>1.4 安装SDL2环境</h2><p>因为模拟运行LittleVgl需要图形化模拟运行库，所以需要下载SDL2</p><p><a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">SDL2下载地址</a></p><ul><li><p>选择下图中的MinGW版本</p><p><img src="http://mypic666.test.upcdn.net/sdl2.png" alt=""></p></li><li><p>下载完成并解压后进入 x86_64-w64-mingw32  (对应MinGW64位版本) </p></li><li><p>复制 <em>…/SDL2-2.0.7/x86_64-w64-mingw32/include/SDL2</em> <strong>文件夹</strong> 到编译器的文件夹下的如下路径<em>…mingw64/x86_64-w64-mingw32/include</em></p></li><li><p>复制 <em>…/SDL2-2.0.7/x86_64-w64-mingw32/lib/</em> <strong>文件夹下所有内容</strong>到编译器的文件夹下的如下路径 <em>…mingw64/x86_64-w64-mingw32/lib</em></p></li></ul><p>至此环境已经配置完成。</p><h1 id="2-导入LittleVgl工程"><a href="#2-导入LittleVgl工程" class="headerlink" title="2. 导入LittleVgl工程"></a>2. 导入LittleVgl工程</h1><p>首先Git LittleVgl的工程包</p><p>git地址：<a href="https://github.com/littlevgl/pc_simulator.git" target="_blank" rel="noopener">https://github.com/littlevgl/pc_simulator.git</a></p><ul><li><p>启动Eclipse CDT 并设置工作路径</p><p><img src="http://mypic666.test.upcdn.net/eclp.png" alt=""></p></li><li><p>将Git到的pc_simulator文件夹复制到上面设置的工作路径中</p></li><li><p>打开Eclipse CDT 后选择 【文件】&gt;【导入】</p><p>并选择【常规】&gt;【现有项目到工作空间】</p><p><img src="http://mypic666.test.upcdn.net/gzkj.png" alt=""></p><p>​</p></li><li><p>再将根目录定位到 pc_simulator 文件夹,点击完成后即可导入</p><p><img src="http://mypic666.test.upcdn.net/sz.png" alt=""></p></li></ul><h1 id="3-配置项目文件"><a href="#3-配置项目文件" class="headerlink" title="3. 配置项目文件"></a>3. 配置项目文件</h1><p>  ​</p><ul><li><p>pc_simulator项目上（如下图）, 【右键】&gt;【属性】</p><p><img src="http://mypic666.test.upcdn.net/1111.png" alt=""></p></li><li><p>打开之后可以看到下图，在下图中点击【添加】，输入 mingw32，并点击【上移】到最上面一个，最后点击应用。</p><p><img src="http://mypic666.test.upcdn.net/mingw.png" alt=""></p><p>​</p></li><li><p>再打开如下图选项，选择 MinGW GCC 工具，并点击 【应用】。</p><p><img src="http://mypic666.test.upcdn.net/gjj.png" alt=""></p></li><li><p>再点击【apply and close】关闭</p></li><li><p>将之前下载的SDL2文件夹中的 ..\x86_64-w64-mingw32\bin\SDL2.dll 文件 复制到 你项目中的 ..\pc_simulator\Debug 文件夹下</p></li><li><p>在Eclipse CDT中 按 <code>Ctrl + B</code>  进行编译</p></li><li><p>点击工具栏中的 <strong>运行配置</strong> 选项，如下图</p><p><img src="http://mypic666.test.upcdn.net/gjl.png" alt=""></p></li><li><p>打开下图运行配置窗口,将 C/C++ 程序定位到项目中的Debug文件夹中生成的.exe文件</p><p><img src="http://mypic666.test.upcdn.net/xxx.png" alt=""></p></li><li><p>然后点击窗口右下角运行后即可显示模拟效果</p><p><img src="http://mypic666.test.upcdn.net/sim.png" alt=""></p></li></ul>]]></content>
      
      <categories>
          
          <category> LittlevGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LittlevGL </tag>
            
            <tag> 模拟器 </tag>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Slab</title>
      <link href="/2017/05/18/Slab/"/>
      <url>/2017/05/18/Slab/</url>
      <content type="html"><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>传统的内存分配算法有两种，固定块大小分配法和块相连分配法：</p><ul><li>固定块大小分配法（如ucos ii的内存管理）：分配速度快，算法实现简单，但由于只支持固定的一种或几种的固定块大小，使得内存空间利用率低，不够灵活，不适用于相对复杂的应用。</li><li>块相连分配法：通过指针链表的形式能够实现比较灵活的不同内存大小的分配，但经常需要遍历整个链表，导致耗时长，且容易产生碎片。</li></ul><p><strong>而RT-Thread的slab内存分配算法是上述两种算法的折中，其分两层：</strong></p><ul><li><strong>底层是页分配器</strong></li><li><strong>上层是slab分配器</strong></li></ul><p>其页分配器的本质其实一个以page为单位块相连的分配算法，而其slab分配器则相当个支持72种大小的固定块分配法，所以RT-Thread的slab内存分配算法很好的兼顾了内存分配时的快速性、灵活性、不易产生碎片等要求。而其底层是已page为单位的分配，所以特别适合带虚拟内存交换机制的系统。</p><a id="more"></a><h1 id="slab内存分配"><a href="#slab内存分配" class="headerlink" title="slab内存分配"></a>slab内存分配</h1><h2 id="底层的页分配器算法"><a href="#底层的页分配器算法" class="headerlink" title="底层的页分配器算法"></a>底层的页分配器算法</h2><p>涉及到的函数、变量、数据结构有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">rt_page_alloc</span><span class="params">(<span class="keyword">rt_size_t</span> npages)</span>   <span class="comment">//分配页</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_free</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">rt_size_t</span> npages)</span> <span class="comment">//释放页</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_page_init</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">rt_size_t</span> npages)</span> <span class="comment">//页分配器初始化</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_system_heap_init</span><span class="params">(<span class="keyword">void</span> *begin_addr, <span class="keyword">void</span>* end_addr)</span>  <span class="comment">//内存管理初始化</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct rt_page_head <span class="comment">//链表数据结构，正是通过这个数据结构将搜索的页形成一个链表</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">next</span>;</span>      <span class="comment">/* next valid page */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">rt_size_t</span> page;                 <span class="comment">/* number of page  */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> dummy[RT_MM_PAGE_SIZE - (<span class="keyword">sizeof</span>(structrt_page_head*) + <span class="keyword">sizeof</span> (<span class="keyword">rt_size_t</span>))];</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rt_page_head</span> *<span class="title">rt_page_list</span>;</span>  <span class="comment">//指向首个可用于分配的页</span></span><br></pre></td></tr></table></figure><p>我们先从rt_system_heap_init入手，可以看到调用rt_page_init对页分配器进行了初始化。</p><ul><li>下图可以看到，在每个连续的空间页的首地址收存放着一个数据结构struct rt_page_head，其元素page代表接下来有多少个连续的空间页可用于分配，next指向下一个与其不连续的空闲页。而全局的链表指针rt_page_list则指向首个可用于分配的空闲页。</li><li>下图还可以看到，RT-Thread的页分配器和常见的块相连分配法的原理一样，但它又有自己的特：<ul><li>它是已页为单位的分配。</li><li>分配之后不需要花空间去记录这次分配的大小，因为上层的slab分配器使用页分配器时都是分配zone_size/4（zone_size一般为128K）大小个的页。</li><li>已分配的页的起始地址的数据内存管理程序已不再使用，完全可以交给申请者使用。</li></ul></li></ul><p><img src="http://img.ph.126.net/Li5oc8TmIrNWxODv4c5Dgg==/626281823198544047.jpg" alt=""></p><h2 id="上层的slab分配器"><a href="#上层的slab分配器" class="headerlink" title="上层的slab分配器"></a>上层的slab分配器</h2><p>首先来解释两个概念，<strong>一个是zone、另一个是chunk</strong></p><ul><li>Chunk：chunk是指一段固定大小的空间，slab分配器中共支持72种大小的chunk，那72种大小分别是8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128、144、160、176、192、208、224、240、256、288、320、352、384、416、448、480、512、576、640、704、770、834、898、962、1024、1152、1280、1408、1536、1664、1792、1920、2048、2304、2560、2816、3072、3328、3584、3840、4096、4608、5120、5632、6144、6656、7168、7680、8192、9216、10240、11264、12288、13312、14336、15360、16384（具体规律可参考zoneindex函数）。也就是说slab内存分配器只能分配上述大小的空间，如果过需要分配的空间不等上述大小，则会通过zoneindex函数自动寻找一个最接近的大小来代替，如果要分配的空间大于16K则，则直接分配一个4K大小对齐的空间。</li><li>Zone：每个zone一般都是128K，每个zone里包含着n个大小相同的chunk，所以就有72种类型的zone。如某个zone为128K，chunk属于512字节的类型，则说明它包含着128*1024/512个chunk。</li></ul><p>接下来说一些主要的数据结构和全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_magic;    <span class="comment">//没什么主要用途，可以不分析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_nfree;    <span class="comment">//该zone里有多少个可用于分配的chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_nmax;     <span class="comment">//该zone里拥有多少个chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">slab_zone</span> *<span class="title">z_next</span>;</span>  <span class="comment">//指向下一个同样类型的zone，并且所指向的zone中的chunk没有分配完，否则为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_uint8_t</span> *z_baseptr;     <span class="comment">//该zone第一个chunk的偏移，因为zone起始地址存放着这个数据结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_uindex;       <span class="comment">//每次分配chunk就自加1，直到z_uindex+1= z_nmax,就会从z_freechunk中寻找可分配的chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_chunksize;   <span class="comment">//该zone中每个chunk的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">rt_int32_t</span> z_zoneindex;   <span class="comment">//对应的zoneindex，其实就是跟chunk的大小有关，大小为8时index为0，大小为16384时index为71</span></span><br><span class="line"></span><br><span class="line">    slab_chunk *z_freechunk; <span class="comment">//指向该zone中首个已被free掉的chunk，如果没有则为NULL</span></span><br><span class="line"></span><br><span class="line">&#125; slab_zone;</span><br></pre></td></tr></table></figure><p>该数据结构存放在没有zone的起始空间中，描述了该zone的类型，该zone里面有哪些chunk可用于分配，哪些chunk被free了，下一个同类型的zone的地址等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memusage</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_uint32_t</span> type:<span class="number">2</span> ;                   <span class="comment">//记录着对应空间分配的chunk是小于等于16K类型的还是大于16K的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_uint32_t</span> size:<span class="number">30</span>;    <span class="comment">//如果是大于16K的类型，则记录具体分配的大小，否则记录该页在zone中的编号（因为每个zone包含32个页，也就是记录页号）</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个堆空间有多少个页就会开辟多少个这样的数据结构记录着对应页的状态。</p><p><code>zone_array[NZONES]</code></p><p>有72种类型的zone，所以就有上述的72的指针数组，分别指向对应类型的zone的首地址，然后这个zone数据结构又会指向下一个同类型的zone，所以全部同类型的zone就组成了一个链表。</p><p>接下来说说一下大概分配内存的过程：</p><ul><li>首先初始化的时候zone_array[NZONES]会被全部置空，表明没有任何可用的zone，然后调用rt_malloc（200）申请200字节的空间，通过zoneindex函数后调整申请大小为208，且zoneindex为20，然后查询zone_array[20]发现为空，则说明208字节chunk大小类型的zone没有被建立或者没有一个包含空闲chunk的这样类型的zone。</li><li>然后就会建立一个新的且chunk大小为208字节的zone，通过rt_page_alloc 32个page实现，因为每个zone都为32*4K大小。</li><li>然后在所申请的页对应的memusage数组设置相应的标志及编号，然后初始化slab_zone数据结构，然后返回该zone内第一个chunk的地址，申请成功。</li></ul><p><img src="http://mypic666.test.upcdn.net/626281823198544048.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/626281823198544049.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/1009650741478466271.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/1009650741478466272.jpg" alt=""></p><p><img src="http://mypic666.test.upcdn.net/626281823198544050.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> slab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机字符编码</title>
      <link href="/2016/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2016/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="计算机编码"><a href="#计算机编码" class="headerlink" title="计算机编码"></a>计算机编码</h1><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节”。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”</p><p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><a id="more"></a> <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>字符(Character)</strong> 是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</li><li><strong>字符集(Character set)</strong> 是一个系统支持的所有抽象字符的集合。通常以二维表的形式存在，二维表的内容和大小是由使用者的语言而定。如ASCII,GBxxx,Unicode等。</li><li><strong>字符编码(Character encoding)</strong> 是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。每个字符集中的字符都对应一个唯一的二进制编码。</li></ul><h1 id="常见字符集及编码"><a href="#常见字符集及编码" class="headerlink" title="常见字符集及编码"></a>常见字符集及编码</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><strong>ASCII(American Standard Code for Information Interchange, 美国信息交换标准代码)</strong>是基于拉丁字母的一套电脑编码系统，使用7个或8个二进制位进行编码的方案，最多可以给256个字符 (包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值。 它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准<strong>ISO/IEC 646</strong>。</p><p>ASCII码于1961年提出，用于在不同计算机硬件和软件系统中实现数据传输标准化，在大多数的小型机和全部的个人计算机都使用此码。ASCII码划分为两个集合：128个字符的标准ASCII码和附加的128个字符的扩充和ASCII码。</p><p> 目前使用最广泛的西文字符集及其编码是 ASCII 字符集和 ASCII 码（ ASCII 是 American Standard Code for Information Interchange 的缩写），它同时也被国际标准化组织（ International Organization for Standardization, ISO ）批准为国际标准。</p><p> 基本的 ASCII 字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。标准 ASCII 码使用 7 个二进位对字符进行编码，对应的 ISO 标准为 ISO646 标准。下表展示了基本 ASCII 字符集及其编码：</p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=c05506e79482d158af8f51e3e16372bd/c2fdfc039245d688c56332adacc27d1ed21b2451.jpg" alt=""></p><p>Unicode,GBXXX,UTF-8等字符编码都兼容ASCII编码。</p><p><strong>EASCII</strong>(Extended ASCII，延伸美国标准信息交换码)是将ASCII码由7位扩充为8位而成。EASCII的内码是由0到255共有256个字符组成。EASCII码比ASCII码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号。</p><h2 id="MBCS"><a href="#MBCS" class="headerlink" title="MBCS"></a>MBCS</h2><p>为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI 编码即可。 不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。一个很大的缺点是，同一个编码值，在不同的编码体系里代表着不同的字。这样就容易造成混乱。</p><p>导致了unicode码的诞生。 其中每个语言下的ANSI编码，都有一套一对一的编码转换器，Unicode变成所有编码转换的中间介质。所有的编码都有一个转换器可以转换到Unicode，而Unicode也可以转换到其他所有的编码。</p><h2 id="GB2312字符集-amp-编码"><a href="#GB2312字符集-amp-编码" class="headerlink" title="GB2312字符集&amp;编码"></a>GB2312字符集&amp;编码</h2><p><strong>GB 2312</strong> 或称 <strong>GB 2312–80</strong> 是中华人民共和国国家标准简体中文字符集，全称《<strong>信息交换用汉字编码字符集·基本集</strong>》，又称<strong>GB0</strong>，由中国国家标准总局发布，1981年5月1日实施。GB 2312编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。</p><p><strong>字符集范围</strong></p><p>GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。</p><p>GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312不能处理，因此后来GBK及GB 18030汉字字符集相继出现以解决这些问题。</p><p> <strong>分区</strong></p><p>GB 2312中对所收汉字进行了“分区”处理，每区含有94个汉字／符号。这种表示方式也称为区位码。</p><table><thead><tr><th>分区范围</th><th>符号类型</th></tr></thead><tbody><tr><td>第01区</td><td>中文标点、数学符号以及一些特殊字符</td></tr><tr><td>第02区</td><td>各种各样的数学序号</td></tr><tr><td>第03区</td><td>全角西文字符</td></tr><tr><td>第04区</td><td>日文平假名</td></tr><tr><td>第05区</td><td>日文片假名</td></tr><tr><td>第06区</td><td>希腊字母表</td></tr><tr><td>第07区</td><td>俄文字母表</td></tr><tr><td>第08区</td><td>中文拼音字母表</td></tr><tr><td>第09区</td><td>制表符号</td></tr><tr><td>第10－15区</td><td>无字符</td></tr><tr><td>第16－55区</td><td>一级汉字（以拼音字母排序）</td></tr><tr><td>第56－87区</td><td>二级汉字（以部首笔画排序）</td></tr><tr><td>第88－94区</td><td>无字符</td></tr></tbody></table><p>举例来说，“啊”字是GB 2312之中的第一个汉字，它的区位码就是1601。<br>10–15区及88–94区则未有编码。</p><p><strong>编码格式</strong></p><p>在使用GB 2312的程序通常采用<a href="https://zh.wikipedia.org/wiki/EUC" target="_blank" rel="noopener">EUC</a>储存方法，以便兼容于ASCII。<br>每个汉字及符号以两个字节来表示。第一个字节称为“高位字节”，第二个字节称为“低位字节”。<br>“高位字节”使用了<code>0xA1–0xF7</code>（把01–87区的区号加上0xA0），“低位字节”使用了<code>0xA1–0xFE</code>（把01–94加上0xA0）。 由于一级汉字从16区起始，汉字区的“高位字节”的范围是0xB0–0xF7，“低位字节”的范围是0xA1–0xFE，占用的码位是72*94=6768。其中有5个空位是D7FA–D7FE。</p><h2 id="GBK字符集-amp-编码"><a href="#GBK字符集-amp-编码" class="headerlink" title="GBK字符集&amp;编码"></a>GBK字符集&amp;编码</h2><p><strong>汉字内码扩展规范</strong>，称<strong>GBK</strong>，全名为<strong>《汉字内码扩展规范(GBK)》1.0版</strong>，由中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订，国家技术监督局标准化司和电子工业部科技与质量监督司1995年12月15日联合以《技术标函[1995]229号》文件的形式公布。</p><p>GBK的<strong>K</strong>为汉语拼音Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Extension Specification。</p><p>GB 2312-80只收录6763个汉字，有不少汉字，如部分在GB 2312-80推出以后才简化的汉字（如“啰”），部分人名用字（如中国前总理朱镕基的“镕”字），台湾及香港使用的繁体字，日语及朝鲜语汉字等，并未有收录在内。GBK对GB 2312-80进行扩展, 总计拥有 23940 个码位，共收入21886个汉字和图形符号，其中汉字（包括部首和构件）21003 个，图形符号883 个。</p><p><strong>计算公式</strong></p><p>GBK码对字库中偏移量的计算公式为：</p><p>[(GBKH-0x81)<em>0xBE+(GBKL-0x41)]</em>(汉字离散后每个汉字点阵所占用的字节)</p><p><strong>编码格式</strong></p><p>GBK有一<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>和双字节编码，00–7F范围内是一位，和<a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a>保持一致，此范围内严格上说有96个字符和32个控制符号。</p><p>之后的双<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>中，前一字节是双字节的第一位。总体上说第一<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>的范围是81–FE（也就是不含80和FF），第二字节的一部分领域在40–7E，其他领域在80–FE。</p><p><img src="pic cache/gbk.png" alt=""></p><p>GBK向下完全兼容GB2312-80编码。支持GB2312-80编码不支持的部分中文姓，中文繁体，日文假名，还包括希腊字母以及俄语字母等字母。不过这种编码不支持韩国字，也是其在实际使用中与unicode编码相比欠缺的部分。</p><h2 id="GB-18030字符集-amp-编码"><a href="#GB-18030字符集-amp-编码" class="headerlink" title="GB 18030字符集&amp;编码"></a>GB 18030字符集&amp;编码</h2><p><strong>GB 18030</strong>，全称：国家标准GB 18030-2005《信息技术　中文编码字符集》，是中华人民共和国现时最新的内码字集，是GB 18030-2000《信息技术　信息交换用汉字编码字符集　基本集的扩充》的修订版。与GB 2312-1980完全兼容，与GBK基本兼容；支持GB 13000（93版等同于Unicode 1.1；2010版等同于Unicode 4.0）及Unicode的全部统一汉字，共收录汉字70,244个。</p><p>本规格的初版是由中华人民共和国信息产业部电子工业标准化研究所起草，由国家质量技术监督局于2000年3月17日发布。现行版本为国家质量监督检验总局和中国国家标准化管理委员会于2005年11月8日发布，2006年5月1日实施。</p><p>此标准内的单字节编码部分、双字节编码部分，和四字节编码部分收录的中日韩统一表意文字扩展A区汉字，为强制性标准。其他部分则属于规模性标准。在中华人民共和国境内所有软件产品，都需要支持这个同时包含单字节、双字节和四字节编码的规格。</p><p>GB 18030主要有以下特点：</p><ul><li>和UTF-8一样都采用多字节编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字元。</li><li>支持中国国内少数民族的文字，不需要动用造字区。</li><li>汉字收录范围包含繁体汉字以及日韩汉字。</li></ul><p><strong>编码方式</strong></p><ul><li>单字节，其值从0x00到0x7F。</li><li>双字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x40到0xFE（不包括0x7F）。</li><li>四字节，第一个字节的值从0x81到0xFE，第二个字节的值从0x30到0x39，第三个字节从0x81到0xFE，第四个字节从0x30到0x39。</li></ul><h2 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h2><p>在台湾、香港与澳门地区，使用的是繁体中文字符集。而1980年发布的GB2312面向简体中文字符集，并不支持繁体汉字。在这些使用繁体中文字符集的地区，一度出现过很多不同厂商提出的字符集编码，这些编码彼此互不兼容，造成了信息交流的困难。为统一繁体字符集编码，1984年，台湾五大厂商宏碁、神通、佳佳、零壹以及大众一同制定了一种繁体中文编码方案，因其来源被称为五大码，英文写作Big5，后来按英文翻译回汉字后，普遍被称为大五码。</p><p>大五码是一种繁体中文汉字字符集，其中繁体汉字13053个，808个标点符号、希腊字母及特殊符号。大五码的编码码表直接针对存储而设计，每个字符统一使用两个字节存储表示。第1字节范围81H－FEH，避开了同ASCII码的冲突，第2字节范围是40H－7EH和A1H－FEH。因为Big5的字符编码范围同GB2312字符的存储码范围存在冲突，所以在同一正文不能对两种字符集的字符同时支持。</p><p>Big5编码的分布如表1－5所示，Big5字符主要部分集中在三个段内：标点符号、希腊字母及特殊符号；常用汉字；非常用汉字。其余部分保留给其他厂商支持。</p><p>Big5字符编码分布表</p><table><thead><tr><th>编码范围</th><th>符号类别</th></tr></thead><tbody><tr><td>8140H－A0FEH</td><td>保留（用作造字区）</td></tr><tr><td>A140H－A3BFH</td><td>标点符号、希腊字母及特殊符号</td></tr><tr><td>A3C0H－A3FEH</td><td>保留（未开放用于造字区）</td></tr><tr><td>A440H－C67EH</td><td>常用汉字（先按笔划，再按部首排序）</td></tr><tr><td>C6A1H－C8FEH</td><td>保留（用作造字区）</td></tr><tr><td>C940H－F9D5H</td><td>非常用汉字（先按笔划，再按部首排序）</td></tr><tr><td>F9D6H－FEFEH</td><td>保留（用作造字区）</td></tr></tbody></table><p>Big5编码推出后，得到了繁体中文软件厂商的广泛支持，在使用繁体汉字的地区迅速普及使用。目前，Big5编码在台湾、香港、澳门及其他海外华人中普遍使用，成为了繁体中文编码的事实标准。在互联网中检索繁体中文网站，所打开的网页中，大多都是通过Big5编码产生的文档。</p><h2 id="Unicode字符集-amp-编码"><a href="#Unicode字符集-amp-编码" class="headerlink" title="Unicode字符集&amp;编码"></a>Unicode字符集&amp;编码</h2><p>世界上存在着多种编码方式，在ANSi编码下，同一个编码值，在不同的编码体系里代表着不同的字。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，可能最终显示的是中文，也可能显示的是日文。在ANSI编码体系下，要想打开一个文本文件，不但要知道它的编码方式，还要安装有对应编码表，否则就可能无法读取或出现乱码。为什么电子邮件和网页都经常会出现乱码，就是因为信息的提供者可能是日文的ANSI编码体系和信息的读取者可能是中文的编码体系，他们对同一个二进制编码值进行显示，采用了不同的编码，导致乱码。</p><p>如果有一种编码，将世界上所有的符号都纳入其中，无论是英文、日文、还是中文等，大家都使用这个编码表，就不会出现编码不匹配现象。每个符号对应一个唯一的编码，乱码问题就不存在了。这就是Unicode编码。</p><p><strong>Unicode</strong>（中文：<strong>万国码</strong>、<strong>国际码</strong>、<strong>统一码</strong>、<strong>单一码</strong>）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。<br>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2016年6月21日公布的9.0.0,已经收入超过十万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p><p>Unicode发展由非营利机构统一码联盟负责，该机构致力于让Unicode方案替换既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。</p><p>Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言、Java编程语言以及现代的操作系统，都采用Unicode编码。</p><p><strong>编码方式</strong></p><p>统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示2的16次方（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。</p><p>Unicode原编码占用两个字节,在使用ASCII字符时,高位字节的8位始终为0,这会造成空间的浪费。为了避免这种浪费，Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为<strong>Unicode转换格式</strong>（Unicode Transformation Format，简称为UTF）。<br>UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。</p><h2 id="UTF-8-编码"><a href="#UTF-8-编码" class="headerlink" title="UTF-8 编码"></a>UTF-8 编码</h2><p><strong>UTF-8</strong>（<strong>8-bit Unicode Transformation Format</strong>）是一种针对Unicode的可变长度字符编码，也是一种前缀码。其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。</p><p>UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节）：</p><ul><li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</li><li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</li><li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</li><li>其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。</li></ul><p>对上述提及的第四种字符而言，UTF-8使用四至六个字节来编码似乎太耗费资源了。但UTF-8对所有常用的字符都可以用三个字节表示，而且它的另一种选择，UTF-16编码，对前述的第四种字符同样需要四个字节来编码，所以要决定UTF-8或UTF-16哪种编码比较有效率，还要视所使用的字符的分布范围而定。</p><p><strong>编码方式</strong></p><ul><li>单字节字符的最高有效比特永远为0。</li><li>多字节序列中的首个字符组的几个最高有效比特决定了序列的长度。最高有效位为<code>110</code>的是2字节序列，而<code>1110</code>的是三字节序列，如此类推。</li><li>多字节序列中其余的字节中的首两个最高有效比特为<code>10</code>。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1894803-67a4baf55ee972b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
